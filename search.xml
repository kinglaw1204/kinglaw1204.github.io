<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>你写的Java对象究竟占多少内存？</title>
      <link href="/2020/02/27/java-code-used-memory/"/>
      <url>/2020/02/27/java-code-used-memory/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cdn.pixabay.com/photo/2015/12/06/09/17/silhouette-1079240_1280.jpg" target="_blank" rel="noopener" title="memory"><img src="https://cdn.pixabay.com/photo/2015/12/06/09/17/silhouette-1079240_1280.jpg" alt="memory" title="memory"></a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java 作为一个面向对象语言，给我们带来了多态，继承，封装等特性，使得我们可以利用这些特性很轻松的就能构建出易于扩展，易于维护的代码。作为一个<code>Javaer</code>，天天搞“对象”，那你写的对象究竟占用了多少内存呢？我们来看看你的“对象”是如何“败家”的。</p><blockquote><p>本文环境：jdk1.8_64</p></blockquote><h2 id="Java-对象头内存模型"><a href="#Java-对象头内存模型" class="headerlink" title="Java 对象头内存模型"></a>Java 对象头内存模型</h2><p>我们先来看看，一个Java 对象的内存模型是怎么样的？由于我们的虚拟机是分为32位和64位，那肯定它们的模型也是有区别的，下面我列出列32位虚拟机和64位虚拟机下的<code>Java</code>对象头内存模型。<br><img src="https://github.com/kinglaw1204/blogImage/blob/master/Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8/32%E4%BD%8DJava%E5%AF%B9%E8%B1%A1%E5%A4%B4.png?raw=true" alt="32位虚拟机" title="32位虚拟机"></p><p><img src="https://github.com/kinglaw1204/blogImage/blob/master/Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8/64%E4%BD%8Djava%E5%AF%B9%E8%B1%A1%E5%A4%B4.png?raw=true" alt="64位虚拟机" title="64位虚拟机"></p><p><img src="https://github.com/kinglaw1204/blogImage/blob/master/Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8/64%E4%BD%8Djava%E5%AF%B9%E8%B1%A1%E5%A4%B4%EF%BC%88%E6%8C%87%E9%92%88%E5%8E%8B%E7%BC%A9%EF%BC%89.png?raw=true" alt="64位带指针压缩" title="64位带指针压缩"></p><p>因为笔者的本地环境是<code>jdk1.8</code>,64位虚拟机，这里我以64位虚拟机（开启指针压缩）来分析，因为默认情况下，<code>jdk1.8</code> 在64位虚拟机默认开启指针压缩。</p><p>Java 对象头主要包括两部分，第一部分就是 <code>Mark Word</code>，这也是 <code>Java</code> 锁实现原理中重要的一环，另外一部分是 <code>Klass Word</code>。</p><p><strong>Klass Word</strong>  这里其实是虚拟机设计的一个<code>oop-klass model</code>模型，这里的<code>OOP</code>是指<code>Ordinary Object Pointer</code>（普通对象指针），看起来像个指针实际上是藏在指针里的对象。而 <code>klass</code> 则包含 元数据和方法信息，用来描述 <code>Java</code> 类。它在64位虚拟机开启压缩指针的环境下占用 32bits 空间。</p><p><strong>Mark Word</strong> 是我们分析的重点，这里也会设计到锁的相关知识。<code>Mark Word</code> 在64位虚拟机环境下占用 64bits 空间。整个<code>Mark Word</code>的分配有几种情况：</p><ol><li><strong>未锁定（Normal）：</strong> 哈希码（<code>identity_hashcode</code>）占用31bits，分代年龄（<code>age</code>）占用4 bits，偏向模式（<code>biased_lock</code>）占用1 bits，锁标记（<code>lock</code>）占用2 bits，剩余26bits 未使用(也就是全为0)</li><li><strong>可偏向（Biased）：</strong> 线程id 占54bits，<code>epoch</code> 占2 bits，分代年龄（<code>age</code>）占用4 bits，偏向模式（biased_lock）占用1 bits，锁标记（lock）占用2 bits，剩余 1bit 未使用。</li><li><strong>轻量锁定（Lightweight Locked）</strong>： 锁指针占用62bits，锁标记（<code>lock</code>）占用2 bits。</li><li><strong>重量级锁定（Heavyweight Locked）</strong>：锁指针占用62bits，锁标记（<code>lock</code>）占用2 bits。</li><li><strong>GC 标记</strong>：标记位占2bits，其余为空（也就是填充0）</li></ol><p>以上就是我们对Java对象头内存模型的解析，只要是Java对象，那么就肯定会包括对象头，也就是说这部分内存占用是避免不了的。<strong>所以，在笔者64位虚拟机，Jdk1.8（开启了指针压缩）的环境下，任何一个对象，啥也不做，只要声明一个类，那么它的内存占用就至少是96bits，也就是至少12字节。</strong></p><h2 id="验证模型"><a href="#验证模型" class="headerlink" title="验证模型"></a>验证模型</h2><p>我们来写点代码来验证一下上述的内存模型，这里推荐openjdk的<a href="https://openjdk.java.net/projects/code-tools/jol/" target="_blank" rel="noopener">jol工具</a>，它可以帮助你查看对象内存的占用情况。</p><p>首先添加maven依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jol&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jol-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.10&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>我们先来看看，如果只是新建一个普通的类，什么属性也不添加，占用的空间是多少？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @description:</span><br><span class="line"> * @author: luozhou</span><br><span class="line"> * @create: 2020-02-26 10:00</span><br><span class="line"> **&#x2F;</span><br><span class="line">public class NullObject &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照我们之前的Java对象内存模型分析，一个空对象，那就是只有一个对象头部，在指针压缩的条件下会占用 96 bit，也就是12byte。</p><p>运行工具查看空间占用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       System.out.println(ClassLayout.parseInstance(new NullObject()).toPrintable());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上面这行代码会解析你新建一个NullObject对象，占用了多少内存。我们执行看看结果如何：</p><p><img src="https://github.com/kinglaw1204/blogImage/blob/master/Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8/nullObject%20%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8.png?raw=true" alt="内存占用" title="内存占用"></p><p>这里我们发现结果显示：<code>Instance size：16 bytes</code>,结果就是16字节，我们之前预测的12字节不一样，为什么会这样呢？我们看到上图中有3行 object header，每个占用4字节，所以头部就是12字节，这里和我们的计算是一致的，最后一行是虚拟机填充的4字节，<strong>那为什么虚拟机要填充4个字节呢？</strong></p><h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p>想要知道为什么虚拟机要填充4个字节，我们需要了解什么是内存对齐？</p><p>我们程序员看内存是这样的：<br><img src="https://github.com/kinglaw1204/blogImage/blob/master/Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E7%9C%8B%E5%86%85%E5%AD%98.png?raw=true" alt=""></p><p>上图表示一个坑一个萝卜的内存读取方式。但实际上 CPU 并不会以一个一个字节去读取和写入内存。相反 CPU 读取内存是一块一块读取的，块的大小可以为 2、4、6、8、16 字节等大小。块大小我们称其为内存访问粒度。如下图：</p><p><img src="https://github.com/kinglaw1204/blogImage/blob/master/Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8/%E5%A4%84%E7%90%86%E5%99%A8%E5%A6%82%E4%BD%95%E7%9C%8B%E5%86%85%E5%AD%98.png?raw=true" alt=""></p><p>假设一个32位平台的 CPU，那它就会以4字节为粒度去读取内存块。那为什么需要内存对齐呢？主要有两个原因：</p><ul><li>平台（移植性）原因：不是所有的硬件平台都能够访问任意地址上的任意数据。例如：特定的硬件平台只允许在特定地址获取特定类型的数据，否则会导致异常情况。</li><li>性能原因：若访问未对齐的内存，将会导致 CPU 进行两次内存访问，并且要花费额外的时钟周期来处理对齐及运算。而本身就对齐的内存仅需要一次访问就可以完成读取动作。</li></ul><p>我用图例来说明 CPU 访问非内存对齐的过程：<br><img src="https://github.com/kinglaw1204/blogImage/blob/master/Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90-%E5%86%85%E5%AD%98%E8%AF%BB%E5%8F%96%E8%BF%87%E7%A8%8B.png?raw=true" alt=""></p><p>在上图中，假设CPU 是一次读取4字节，在这个连续的8字节的内存空间中，如果我的数据没有对齐，存储的内存块在地址1，2，3，4中，那CPU的读取就会需要进行两次读取，另外还有额外的计算操作：</p><ol><li>CPU 首次读取未对齐地址的第一个内存块，读取 0-3 字节。并移除不需要的字节 0。</li><li>CPU 再次读取未对齐地址的第二个内存块，读取 4-7 字节。并移除不需要的字节 5、6、7 字节。</li><li>合并 1-4 字节的数据。</li><li>合并后放入寄存器。</li></ol><p>所以，没有进行内存对齐就会导致CPU进行额外的读取操作，并且需要额外的计算。如果做了内存对齐，CPU可以直接从地址0开始读取，一次就读取到想要的数据，不需要进行额外读取操作和运算操作，节省了运行时间。<strong>我们用了空间换时间，这就是为什么我们需要内存对齐。</strong></p><p>回到Java空对象填充了4个字节的问题，<strong>因为原字节头是12字节，64位机器下，内存对齐的话就是128位，也就是16字节，所以我们还需要填充4个字节。</strong></p><h2 id="非空对象占用内存计算"><a href="#非空对象占用内存计算" class="headerlink" title="非空对象占用内存计算"></a>非空对象占用内存计算</h2><p>我们知道了一个空对象是占用16字节，那么一个非空对象究竟占用多少字节呢？我们还是写一个普通类来验证下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class TestNotNull &#123;</span><br><span class="line">    private NullObject nullObject&#x3D;new NullObject();</span><br><span class="line">    private int a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个演示类中引入了别的对象，我们知道<code>int</code>类型是占用4个字节,<code>NullObject</code>对象占用16字节，对象头占12字节，<strong>还有一个很重要的情况 <code>NullObject</code>在当前这个类中是一个引用，所以不会存真正的对象，而只存引用地址</strong>，引用地址占4字节，所以总共就是12+4+4=20字节，内存对齐后就是24字节。我们来验证下是不是这个结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;打印实例的内存布局</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(new TestNotNull()).toPrintable());</span><br><span class="line">        &#x2F;&#x2F;打印对象的所有相关内存占用</span><br><span class="line">        System.out.println(GraphLayout.parseInstance(new TestNotNull()).toPrintable());</span><br><span class="line">        &#x2F;&#x2F;打印对象的所有内存结果并统计</span><br><span class="line">         System.out.println(GraphLayout.parseInstance(new TestNotNull()).toFootprint());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果如下：<br><img src="https://github.com/kinglaw1204/blogImage/blob/master/Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8/jol%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E5%92%8C%E7%BB%9F%E8%AE%A1%E8%AF%A6%E6%83%85.png?raw=true" alt=""></p><p>我们可以看到<code>TestNotNull</code>的类占用空间是24字节，其中头部占用12字节，变量<code>a</code>是<code>int</code>类型，占用4字节,变量<code>nullObject</code>是引用，占用了4字节，最后填充了4个字节，总共是24个字节，与我们之前的预测一致。<strong>但是，因为我们实例化了<code>NullObject</code>,这个对象一会存在于内存中，所以我们还需要加上这个对象的内存占用16字节，那总共就是24bytes+16bytes=40bytes。我们图中最后的统计打印结果也是40字节，所以我们的分析正确。</strong></p><p>这也是如何分析一个对象真正的占用多少内存的思路，根据这个思路加上openJDK的jol工具就可以基本的掌握自己写的“对象”究竟败家了你多少内存。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文我主要讲述了如何分析一个Java对象究竟占用多少内存空间，主要总结点如下：</p><ol><li>Java对象头部内存模型在32位虚拟机和64位虚拟机是不一样的，64位虚拟机又分为开启指针压缩和不开启指针压缩两种对象头模型，所以总共有3种对象头模型。</li><li>内存对齐主要是因为平台的原因和性能的原因，本文主要解析的是性能方面的原因。</li><li>空对象的内存占用计算注意要计算内存对齐，非空对象的内存计算注意加上引用内存占用和原实例对象的空间占用。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.<a href="http://cr.openjdk.java.net/~lfoltan/bug_jdk8067480/src/share/vm/oops/klass.hpp.html" target="_blank" rel="noopener">http://cr.openjdk.java.net/~lfoltan/bug_jdk8067480/src/share/vm/oops/klass.hpp.html</a></p><p>2.<a href="https://gist.github.com/arturmkrtchyan/43d6135e8a15798cc46c" target="_blank" rel="noopener">https://gist.github.com/arturmkrtchyan/43d6135e8a15798cc46c</a></p><p>3.<a href="https://weekly-geekly.github.io/articles/447848/index.html" target="_blank" rel="noopener">https://weekly-geekly.github.io/articles/447848/index.html</a></p><p>4.<a href="https://developer.ibm.com/articles/pa-dalign/" target="_blank" rel="noopener">https://developer.ibm.com/articles/pa-dalign/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker是如何实现隔离的</title>
      <link href="/2020/01/21/docker-islotion/"/>
      <url>/2020/01/21/docker-islotion/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2015/01/15/14/51/wal-600387_1280.png" alt=""></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>容器化技术在当前云计算、微服务等体系下大行其道，而 Docker 便是容器化技术的典型，对于容器化典型的技术，我们有必要弄懂它，所以这篇文章，我会来分析下 Docker 是如何实现隔离技术的，Docker 与虚拟机又有哪些区别呢？接下来，我们开始逐渐揭开它的面纱。</p><h2 id="从运行一个容器开始"><a href="#从运行一个容器开始" class="headerlink" title="从运行一个容器开始"></a>从运行一个容器开始</h2><p>我们开始运行一个简单的容器，这里以<code>busybox</code>镜像为例，它是一个常用的Linux工具箱，可以用来执行很多Linux命令，我们以它为镜像启动容器方便来查看容器内部环境。<br>执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name demo_docker busybox &#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure><p>这条命令的意思是：启动一个<code>busybox</code>镜像的 Docker 容器，<code>-it</code>参数表示给容器提供一个输出/输出的交互环境，也就是TTY。<code>/bin/sh</code>表示容器交互运行的命令或者程序。</p><h2 id="进程的隔离"><a href="#进程的隔离" class="headerlink" title="进程的隔离"></a>进程的隔离</h2><p>执行成功后我们就会进入到了 Docker 容器内部,我们执行<code>ps -ef</code> 查看进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F; # ps -ef</span><br><span class="line">PID   USER     TIME  COMMAND</span><br><span class="line">    1 root      0:00 &#x2F;bin&#x2F;sh</span><br><span class="line">    8 root      0:00 ps -ef</span><br></pre></td></tr></table></figure><p>使用<code>top</code>命令查看进程资源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Mem: 1757172K used, 106080K free, 190676K shrd, 129872K buff, 998704K cached</span><br><span class="line">CPU:  0.0% usr  0.2% sys  0.0% nic 99.6% idle  0.0% io  0.0% irq  0.0% sirq</span><br><span class="line">Load average: 0.00 0.01 0.05 2&#x2F;497 9</span><br><span class="line">  PID  PPID USER     STAT   VSZ %VSZ CPU %CPU COMMAND</span><br><span class="line">    1     0 root     S     1300  0.0   1  0.0 &#x2F;bin&#x2F;sh</span><br><span class="line">    9     1 root     R     1292  0.0   3  0.0 top</span><br></pre></td></tr></table></figure><p>而我们在宿主机查看下当前执行容器的进程<code>ps -ef|grep busybox</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root       5866   5642  0 01:19 pts&#x2F;4    00:00:00 &#x2F;usr&#x2F;bin&#x2F;docker-current run -it --name demo_docker busybox &#x2F;bin&#x2F;sh</span><br><span class="line">root       5952   5759  0 01:20 pts&#x2F;11   00:00:00 grep --color&#x3D;auto busybox</span><br></pre></td></tr></table></figure><p>这里我们可以知道，对于宿主机 <code>docker run</code>执行命令启动的只是一个进程，它的<code>pid</code>是5866。而对于容器程序本身来说，它被隔离了，在容器内部都只能看到自己内部的进程，那 Docker 是如何做到的呢？它其实是借助了Linux内核的<code>Namespace</code>技术来实现的，这里我结合一段C程序来模拟一下进程的隔离。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;mount.h&gt;</span><br><span class="line">&#x2F;* 定义一个给 clone 用的栈，栈大小1M *&#x2F;</span><br><span class="line">#define STACK_SIZE (1024 * 1024)</span><br><span class="line">static char container_stack[STACK_SIZE];</span><br><span class="line"></span><br><span class="line">char* const container_args[] &#x3D; &#123;</span><br><span class="line">    &quot;&#x2F;bin&#x2F;bash&quot;,</span><br><span class="line">    NULL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int container_main(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;容器进程[%5d] ----进入容器!\n&quot;,getpid());</span><br><span class="line">    mount(&quot;proc&quot;, &quot;&#x2F;proc&quot;, &quot;proc&quot;, 0, NULL);</span><br><span class="line">    &#x2F;**执行&#x2F;bin&#x2F;bash *&#x2F;</span><br><span class="line">    execv(container_args[0], container_args);</span><br><span class="line">    printf(&quot;出错啦!\n&quot;);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;宿主机进程[%5d] - 开始一个容器!\n&quot;,getpid());</span><br><span class="line">    &#x2F;* 调用clone函数 *&#x2F;</span><br><span class="line">    int container_pid &#x3D; clone(container_main, container_stack+STACK_SIZE,  CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, NULL);</span><br><span class="line">    &#x2F;* 等待子进程结束 *&#x2F;</span><br><span class="line">    waitpid(container_pid, NULL, 0);</span><br><span class="line">    printf(&quot;宿主机 - 容器结束!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到很多同学对C语言不是很熟悉，我这里简单解释下这段程序，这段程序主要就是执行<code>clone()</code>函数，去克隆一个进程，而克隆执行的程序就是我们的<code>container_main</code>函数，接着下一个参数就是栈空间，然后<code>CLONE_NEWPID</code>和<code>CLONE_NEWNS</code> 表示Linux NameSpace的调用类别，分别表示创建新的进程命名空间和 挂载命名空间。</p><ul><li><p><code>CLONE_NEWPID</code>会让执行的程序内部重新编号<code>PID</code>，也就是从<code>1</code>号进程开始</p></li><li><p><code>CLONE_NEWNS</code> 会克隆新的挂载环境出来，通过在子进程内部重新挂载<code>proc</code>文件夹，可以屏蔽父进程的进程信息。</p></li></ul><p>我们执行一下这段程序来看看效果。</p><p><strong>编译</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc container.c -o container</span><br></pre></td></tr></table></figure><p><strong>执行</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@host1 luozhou]# .&#x2F;container </span><br><span class="line">宿主机进程[ 6061] - 开始一个容器!</span><br><span class="line">容器进程[    1] ----进入容器!</span><br></pre></td></tr></table></figure><p>这里我们看到输出在宿主机看来，这个程序的<code>PID</code>是<code>6061</code>，在克隆的子进程来看，它的<code>PID</code>是<code>1</code>，我们执行<code>ps -ef</code> 查看一下进程列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@host1 luozhou]# ps -ef</span><br><span class="line">UID         PID   PPID  C STIME TTY          TIME CMD</span><br><span class="line">root          1      0  0 01:46 pts&#x2F;2    00:00:00 &#x2F;bin&#x2F;bash</span><br><span class="line">root         10      1  0 01:48 pts&#x2F;2    00:00:00 ps -ef</span><br></pre></td></tr></table></figure><p>我们发现确实只有容器内部的进程在运行了，再执行<code>top</code>命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                                  </span><br><span class="line">  1 root      20   0  115576   2112   1628 S   0.0  0.1   0:00.00 bash                                                                                                     </span><br><span class="line"> 11 root      20   0  161904   2124   1544 R   0.0  0.1   0:00.00 top</span><br></pre></td></tr></table></figure><p>结果也只有2个进程的信息。</p><p>这就是容器隔离进程的基本原理了，Docker主要就是借助 Linux 内核技术Namespace来做到隔离的，其实包括我后面要说到文件的隔离，资源的隔离都是在新的命名空间下通过<code>mount</code>挂载的方式来隔离的。</p><h2 id="文件的隔离"><a href="#文件的隔离" class="headerlink" title="文件的隔离"></a>文件的隔离</h2><p>了解完进程的隔离，相信你们已经对 Docker 容器的隔离玩法就大概的印象了，我们接下来看看，Docker 内部的文件系统如何隔离，也就是你在 Docker 内部执行 <code>ls</code> 显示的文件夹和文件如何来的。</p><p>我们还是以前面的 Docker 命令为例，执行<code>ls</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin   dev   etc   home  proc  root  run   sys   tmp   usr   var</span><br></pre></td></tr></table></figure><p>我们发现容器内部已经包含了这些文件夹了，那么这些文件夹哪里来的呢？我们先执行<code>docker info</code>来看看我们的 Docker 用到的文件系统是什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Server Version: 1.13.1</span><br><span class="line">Storage Driver: overlay2</span><br></pre></td></tr></table></figure><p>我的版本是1.13.1，存储驱动是<code>overlay2</code>,不同的存储驱动在 Docker 中表现不一样，但是原理类似，我们来看看 Docker 如何借助<code>overlay2</code>来变出这么多文件夹的。我们前面提到过，Docker都是通过mount 去挂载的,我们先找到我们的容器实例id.</p><p>执行<code>docker ps -a |grep demo_docker</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c0afd574aea7        busybox                         &quot;&#x2F;bin&#x2F;sh&quot;                42 minutes ago      Up 42 minutes</span><br></pre></td></tr></table></figure><p>我们再根据我们的容器ID 去查找挂载信息，执行<code>cat /proc/mounts | grep c0afd574aea7</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shm &#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;c0afd574aea716593ceb4466943bbd13e3a081bf84da0779ee43600de0df384b&#x2F;shm tmpfs rw,context&#x3D;&quot;system_u:object_r:container_file_t:s0:c740,c923&quot;,nosuid,nodev,noexec,relatime,size&#x3D;65536k 0 0</span><br></pre></td></tr></table></figure><p>这里出现了一个挂载信息，但是这个记录不是我们的重点，我们需要找到<code>overlay2</code>的挂载信息，所以这里我们还需要执行一个命令:<code>cat /proc/mounts | grep system_u:object_r:container_file_t:s0:c740,c923</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">overlay &#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;9c9318031bc53dfca45b6872b73dab82afcd69f55066440425c073fe681109d3&#x2F;merged overlay rw,context&#x3D;&quot;system_u:object_r:container_file_t:s0:c740,c923&quot;,relatime,lowerdir&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;FWESUOVO6DYTXBBJIQBPUWLN6K:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;l&#x2F;XPKQU6AMUX3AKLAX2BR6V4JQ3R,upperdir&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;9c9318031bc53dfca45b6872b73dab82afcd69f55066440425c073fe681109d3&#x2F;diff,workdir&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;9c9318031bc53dfca45b6872b73dab82afcd69f55066440425c073fe681109d3&#x2F;work 0 0</span><br><span class="line">shm &#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;c0afd574aea716593ceb4466943bbd13e3a081bf84da0779ee43600de0df384b&#x2F;shm tmpfs rw,context&#x3D;&quot;system_u:object_r:container_file_t:s0:c740,c923&quot;,nosuid,nodev,noexec,relatime,size&#x3D;65536k 0 0</span><br></pre></td></tr></table></figure><p>这里<code>overlay</code>挂载并没有和容器id关联起来，所以我们直接根据容器id是找不到 <code>overlay</code>挂载信息的，这里借助了<code>context</code> 去关联的，所以我们通过<code>context</code>就找到了我们挂载的地址啦。我们进入目录看看结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@host1 l]# ls &#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;9c9318031bc53dfca45b6872b73dab82afcd69f55066440425c073fe681109d3&#x2F;merged</span><br><span class="line">bin  dev  etc  home  proc  root  run  sys  tmp  usr  var</span><br></pre></td></tr></table></figure><p>我们发现这个和我们容器的目录是一致的，我们在这个目录下创建一个新的目录，然后看看容器内部是不是会出现新的目录。<br><img src="https://github.com/kinglaw1204/blogImage/blob/master/Docker%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%9A%94%E7%A6%BB%E7%9A%84/Docker%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%9A%94%E7%A6%BB.gif?raw=true" alt="文件系统隔离" title="文件系统隔离"></p><p>上面的图片验证了容器内部的文件内容和挂载的<code>/var/lib/docker/overlay2/ID/merged</code>下是一致的，这就是Docker文件系统隔离的基本原理。</p><h2 id="资源的限制"><a href="#资源的限制" class="headerlink" title="资源的限制"></a>资源的限制</h2><p>玩过 Docker 的同学肯定知道，Docker 还是可以限制资源使用的，比如 CPU 和内存等，那这部分是如何实现的呢？<br>这里就涉及到Linux的另外一个概念<code>Cgroups</code>技术,它是为进程设置资源限制的重要手段，在Linux 中，一切皆文件，所以<code>Cgroups</code>技术也会体现在文件中，我们执行<code>mount -t cgroup</code> 就可以看到<code>Cgroups</code>的挂载情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;systemd type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,xattr,release_agent&#x3D;&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;systemd-cgroups-agent,name&#x3D;systemd)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;devices type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,devices)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,net_prio,net_cls)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,hugetlb)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,perf_event)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;freezer type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,freezer)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;blkio type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,blkio)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,cpuacct,cpu)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;pids type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,pids)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,memory)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,cpuset)</span><br></pre></td></tr></table></figure><p>我们看到上面挂载的目录有包括 <code>cpu</code>和<code>memory</code> 那我们猜测大概就是在这个文件夹下面配置限制信息的了。我们跑一个容器来验证下，执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name&#x3D;&#39;cpu_set_demo&#39; --cpu-period&#x3D;100000 --cpu-quota&#x3D;20000 busybox md5sum &#x2F;dev&#x2F;urandom</span><br></pre></td></tr></table></figure><p>这个命令表示我们需要启动一个容器，这个容器一直产生随机数进行md5计算来消耗CPU，<code>--cpu-period=100000 --cpu-quota=20000</code>表示限制 CPU 使用率在20%，关于这两个参数的详细说明可以点击<a href="https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt" target="_blank" rel="noopener">这里</a></p><p><img src="https://github.com/kinglaw1204/blogImage/blob/master/Docker%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%9A%94%E7%A6%BB%E7%9A%84/cpuset.png?raw=true" alt="进程top" title="进程top"></p><p>我们查看进程消耗情况发现 刚刚启动的容器资源确实被限制在20%，说明 Docker 的CPU限制参数起作用了，那对应在我们的<code>cgroup</code> 文件夹下面是怎么设置的呢？<br>同样，这里的配置肯定是和容器实例id挂钩的，我的文件路径是在<code>/sys/fs/cgroup/cpu/system.slice/docker-5bbf589ae223b347c0d10b7e97cd1461ef82149a6d7fb144e8b01fcafecad036.scope</code>下，<code>5bbf589ae223b347c0d10b7e97cd1461ef82149a6d7fb144e8b01fcafecad036</code> 就是我们启动的容器id了。</p><p>切换到上面的文件夹下，查看我们设置的参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@host1]# cat cpu.cfs_period_us</span><br><span class="line">100000</span><br><span class="line">[root@host1]# cat cpu.cfs_quota_us </span><br><span class="line">20000</span><br></pre></td></tr></table></figure><p>发现这里我们的容器启动设置参数一样,也就是说通过这里的文件值来限制容器的cpu使用情况。这里需要注意的是，不同的Linux版本 Docker Cgroup 文件位置可能不一样，有些是在<code>/sys/fs/cgroup/cpu/docker/ID/</code> 下。</p><h2 id="与传统虚拟机技术的区别"><a href="#与传统虚拟机技术的区别" class="headerlink" title="与传统虚拟机技术的区别"></a>与传统虚拟机技术的区别</h2><p>经过前面的进程、文件系统、资源限制分析，详细各位已经对 Docker 的隔离原理有了基本的认识，那么它和传统的虚拟机技术有和区别呢？这里贴一个网上的Docker和虚拟机区别的图</p><p><img src="https://github.com/kinglaw1204/blogImage/blob/master/Docker%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%9A%94%E7%A6%BB%E7%9A%84/docker%20%E4%B8%8E%E4%BC%A0%E7%BB%9F%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8C%BA%E5%88%AB.jpg?raw=true" alt="图片来源极客时间" title="图片来源极客时间"></p><p>这张图应该可以清晰的展示了虚拟机技术和 Docker 技术的区别了，虚拟机技术是完全虚拟出一个单独的系统，有这个系统去处理应用的各种运行请求，所以它实际上对于性能来说是有影响的。而 Docker 技术 完全是依赖 Linux 内核特性 Namespace 和Cgroup 技术来实现的，本质来说：你运行在容器的应用在宿主机来说还是一个普通的进程，还是直接由宿主机来调度的，相对来说，性能的损耗就很少，这也是 Docker 技术的重要优势。</p><p>Docker 技术由于 还是一个普通的进程，所以隔离不是很彻底，还是共用宿主机的内核，在隔离级别和安全性上没有虚拟机高，这也是它的一个劣势。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章我通过实践来验证了 Docker 容器技术在进程、文件系统、资源限制的隔离原理，最后也比较了虚拟机和 Docker 技术的区别，总的来说 Docker技术由于是一个普通的宿主机进程，所以具有性能优势，而虚拟机由于完全虚拟系统，所以具备了高隔离性和安全性的优势，两者互有优缺点。不过容器化是当下的趋势，相信随着技术的成熟，目前的隔离不彻底的问题也能解决，容器化走天下不是梦。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://people.redhat.com/vgoyal/papers-presentations/vault-2017/vivek-overlayfs-and-containers-presentation-valult-2017.pdf" target="_blank" rel="noopener">http://people.redhat.com/vgoyal/papers-presentations/vault-2017/vivek-overlayfs-and-containers-presentation-valult-2017.pdf</a></li><li><a href="https://docs.docker.com/v17.09/engine/userguide/storagedriver/overlayfs-driver/" target="_blank" rel="noopener">https://docs.docker.com/v17.09/engine/userguide/storagedriver/overlayfs-driver/</a></li><li><a href="https://lwn.net/Articles/259217" target="_blank" rel="noopener">https://lwn.net/Articles/259217</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从1+1=2来理解Java字节码</title>
      <link href="/2019/12/30/analyse-java-code/"/>
      <url>/2019/12/30/analyse-java-code/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2019/12/18/20/04/fantasy-4704796_1280.jpg" alt=""></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前不久《深入理解Java虚拟机》第三版发布了，赶紧买来看了看新版的内容，这本书更新了很多新版本虚拟机的内容，还对以前的部分内容进行了重构，还是值得去看的。本着复习和巩固的态度，我决定来编译一个简单的类文件来分析Java的字节码内容，来帮助理解和巩固Java字节码知识，希望也对阅读本文的你有所帮助。</p><blockquote><p>说明：本次采用的环境是OpenJdk12</p></blockquote><h2 id="编译“1-1”代码"><a href="#编译“1-1”代码" class="headerlink" title="编译“1+1”代码"></a>编译“1+1”代码</h2><p>首先我们需要写个简单的小程序，1+1的程序，学习就要从最简单的1+1开始，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package top.luozhou.test;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @description:</span><br><span class="line"> * @author: luozhou</span><br><span class="line"> * @create: 2019-12-25 21:28</span><br><span class="line"> **&#x2F;</span><br><span class="line">public class TestJava &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a&#x3D;1+1;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写好java类文件后，首先执行命令<code>javac TestJava.java</code> 编译类文件，生成<code>TestJava.class</code>。<br>然后执行反编译命令<code>javap -verbose TestJava</code>，字节码结果显示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">  Compiled from &quot;TestJava.java&quot;</span><br><span class="line">public class top.luozhou.test.TestJava</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 56</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 &#x3D; Methodref          #5.#14         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; Fieldref           #15.#16        &#x2F;&#x2F; java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">   #3 &#x3D; Methodref          #17.#18        &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream.println:(I)V</span><br><span class="line">   #4 &#x3D; Class              #19            &#x2F;&#x2F; top&#x2F;luozhou&#x2F;test&#x2F;TestJava</span><br><span class="line">   #5 &#x3D; Class              #20            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object</span><br><span class="line">   #6 &#x3D; Utf8               &lt;init&gt;</span><br><span class="line">   #7 &#x3D; Utf8               ()V</span><br><span class="line">   #8 &#x3D; Utf8               Code</span><br><span class="line">   #9 &#x3D; Utf8               LineNumberTable</span><br><span class="line">  #10 &#x3D; Utf8               main</span><br><span class="line">  #11 &#x3D; Utf8               ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">  #12 &#x3D; Utf8               SourceFile</span><br><span class="line">  #13 &#x3D; Utf8               TestJava.java</span><br><span class="line">  #14 &#x3D; NameAndType        #6:#7          &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #15 &#x3D; Class              #21            &#x2F;&#x2F; java&#x2F;lang&#x2F;System</span><br><span class="line">  #16 &#x3D; NameAndType        #22:#23        &#x2F;&#x2F; out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">  #17 &#x3D; Class              #24            &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream</span><br><span class="line">  #18 &#x3D; NameAndType        #25:#26        &#x2F;&#x2F; println:(I)V</span><br><span class="line">  #19 &#x3D; Utf8               top&#x2F;luozhou&#x2F;test&#x2F;TestJava</span><br><span class="line">  #20 &#x3D; Utf8               java&#x2F;lang&#x2F;Object</span><br><span class="line">  #21 &#x3D; Utf8               java&#x2F;lang&#x2F;System</span><br><span class="line">  #22 &#x3D; Utf8               out</span><br><span class="line">  #23 &#x3D; Utf8               Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">  #24 &#x3D; Utf8               java&#x2F;io&#x2F;PrintStream</span><br><span class="line">  #25 &#x3D; Utf8               println</span><br><span class="line">  #26 &#x3D; Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  public top.luozhou.test.TestJava();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 8: 0</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;2, args_size&#x3D;1</span><br><span class="line">         0: iconst_2</span><br><span class="line">         1: istore_1</span><br><span class="line">         2: getstatic     #2                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">         5: iload_1</span><br><span class="line">         6: invokevirtual #3                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(I)V</span><br><span class="line">         9: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 10: 0</span><br><span class="line">        line 11: 2</span><br><span class="line">        line 12: 9</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解析字节码"><a href="#解析字节码" class="headerlink" title="解析字节码"></a>解析字节码</h2><p><strong>1.基础信息</strong></p><p>上述结果删除了部分不影响解析的冗余信息，接下来我们便来解析字节码的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">minor version: 0 次版本号，为0表示未使用</span><br><span class="line">major version: 56 主版本号，56表示jdk12，表示只能运行在jdk12版本以及之后的虚拟机中</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flags: ACC_PUBLIC, ACC_SUPER</span><br></pre></td></tr></table></figure><p><code>ACC_PUBLIC</code>:这就是一个是否是public类型的访问标志。</p><p><code>ACC_SUPER</code>: 这个falg是为了解决通过 <code>invokespecial</code> 指令调用 super 方法的问题。可以将它理解成 Java 1.0.2 的一个缺陷补丁，只有通过这样它才能正确找到 super 类方法。从 Java 1.0.2 开始，编译器始终会在字节码中生成 ACC_SUPER 访问标识。感兴趣的同学可以点击<a href="https://bugs.openjdk.java.net/browse/JDK-6527033" target="_blank" rel="noopener">这里</a>来了解更多。</p><p><strong>2.常量池</strong></p><p>接下来，我们将要分析常量池,你也可以对照上面整体的字节码来理解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#1 &#x3D; Methodref          #5.#14         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br></pre></td></tr></table></figure><p>这是一个方法引用，这里的<code>#5</code>表示索引值，然后我们可以发现索引值为5的字节码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#5 &#x3D; Class              #20            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object</span><br></pre></td></tr></table></figure><p>它表示这是一个<code>Object</code>类，同理<code>#14</code>指向的是一个<code>&quot;&lt;init&gt;&quot;:()V</code>表示引用的是初始化方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#2 &#x3D; Fieldref           #15.#16        &#x2F;&#x2F; java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br></pre></td></tr></table></figure><p>上面这段表示是一个字段引用，同样引用了<code>#15</code>和<code>#16</code>,实际上引用的就是<code>java/lang/System</code>类中的<code>PrintStream</code>对象。其他的常量池分析思路是一样的，鉴于篇幅我就不一一说明了，只列下其中的几个关键类型和信息。</p><p><code>NameAndType</code>:这个表示是名称和类型的常量表，可以指向方法名称或者字段的索引，在上面的字节码中都是表示的实际的方法。</p><p><code>Utf8</code>：<strong>我们经常使用的是字符编码，但是这个不是只有字符编码的意思</strong>，它表示一种字符编码是<code>Utf8</code>的字符串。它是虚拟机中最常用的表结构，你可以理解为它可以描述方法，字段，类等信息。<br>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#4 &#x3D; Class              #19 </span><br><span class="line">#19 &#x3D; Utf8               top&#x2F;luozhou&#x2F;test&#x2F;TestJava</span><br></pre></td></tr></table></figure><p>这里表示<code>#4</code>这个索引下是一个类，然后指向的类是<code>#19</code>,<code>#19</code>是一个<code>Utf8</code>表，最终存放的是<code>top/luozhou/test/TestJava</code>,那么这样一连接起来就可以知道<code>#4</code>位置引用的类是<code>top/luozhou/test/TestJava</code>了。</p><p><strong>3.构造方法信息</strong></p><p>接下来，我们分析下构造方法的字节码，我们知道，一个类初始化的时候最先执行它的构造方法，如果你没有写构造方法，系统会默认给你添加一个无参的构造方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public top.luozhou.test.TestJava();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 8: 0</span><br></pre></td></tr></table></figure><p><code>descriptor: ()V</code> :表示这是一个没有返回值的方法。</p><p><code>flags: ACC_PUBLIC</code>:是公共方法。</p><p><code>stack=1, locals=1, args_size=1</code> :表示栈中的数量为1，局部变量表中的变量为1，调用参数也为1。</p><p>这里为什么都是1呢？这不是默认的构造方法吗？哪来的参数？其实Java语言有一个潜规则：<strong>在任何实例方法里面都可以通过<code>this</code>来访问到此方法所属的对象</strong>。而这种机制的实现就是通过Java编译器在编译的时候作为入参传入到方法中了，熟悉<code>python</code>语言的同学肯定会知道，在<code>python</code>中定义一个方法总会传入一个<code>self</code>的参数,这也是传入此实例的引用到方法内部，Java只是把这种机制后推到编译阶段完成而已。所以，这里的1都是指<code>this</code>这个参数而已。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     0: aload_0</span><br><span class="line">     1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">     4: return</span><br><span class="line">LineNumberTable:</span><br><span class="line">    line 8: 0</span><br></pre></td></tr></table></figure><p>经过上面这个分析对于这个构造方法表达的意思也就很清晰了。</p><p><code>aload_0</code>:表示把局部变量表中的第一个变量加载到栈中，也就是<code>this</code>。</p><p><code>invokespecial</code>:直接调用初始化方法。</p><p><code>return</code>:调用完毕方法结束。</p><p><code>LineNumberTable:</code>这是一个行数的表，用来记录字节码的偏移量和代码行数的映射关系。<code>line 8: 0</code>表示，源码中第8行对应的就是偏移量<code>0</code>的字节码，因为是默认的构造方法，所以这里并无法直观体现出来。</p><p>另外这里会执行<code>Object</code>的构造方法是因为，<code>Object</code>是所有类的父类，子类的构造要先构造父类的构造方法。</p><p><strong>4.main方法信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;2, args_size&#x3D;1</span><br><span class="line">         0: iconst_2</span><br><span class="line">         1: istore_1</span><br><span class="line">         2: getstatic     #2                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">         5: iload_1</span><br><span class="line">         6: invokevirtual #3                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(I)V</span><br><span class="line">         9: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 10: 0</span><br><span class="line">        line 11: 2</span><br><span class="line">        line 12: 9</span><br></pre></td></tr></table></figure><p>有了之前构造方法的分析，我们接下来分析<code>main</code>方法也会熟悉很多，重复的我就略过了，这里重点分析<code>code</code>部分。</p><p><code>stack=2, locals=2, args_size=1</code>:这里的栈和局部变量表为2，参数还是为1。这是为什么呢？因为<code>main</code>方法中声明了一个变量<code>a</code>,所以局部变量表要加一个，栈也是，所以他们是2。那为什么<code>args_size</code>还是1呢？你不是说默认会把<code>this</code>传入的吗？应该是2啊。<strong>注意：之前说的是在任何实例方法中，而这个main方法是一个静态方法，静态方法直接可以通过类+方法名访问，并不需要实例对象，所以这里就没必要传入了</strong>。</p><p><code>0: iconst_2</code>:将<code>int</code>类型2推送到栈顶。</p><p><code>1: istore_1</code>:将栈顶<code>int</code>类型数值存入第二个本地变量。</p><p><code>2: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</code>:获取<code>PrintStream</code>类。</p><p><code>5: iload_1</code>: 把第二个<code>int</code>型本地变量推送到栈顶。</p><p><code>6: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</code>:调用<code>println</code>方法。</p><p><code>9: return</code>:调用完毕结束方法。</p><p>这里的<code>LineNumberTable</code>是有源码的，我们可以对照下我前面描述是否正确：<br><img src="https://github.com/kinglaw1204/blogImage/blob/master/1+1%E7%90%86%E8%A7%A3%E5%AD%97%E8%8A%82%E7%A0%81/sourceCode.png?raw=true" alt=""></p><p><code>line 10: 0</code>: 第10行表示<code>0: iconst_2</code>字节码，这里我们发现编译器直接给我们计算好了把2推送到栈顶了。</p><p><code>line 11: 2</code>:第11行源码对应的是<code>2: getstatic</code> 获取输出的静态类<code>PrintStream</code>。</p><p><code>line 12: 9</code>:12行源码对应的是<code>return</code>，表示方法结束。</p><p>这里我也画了一个动态图片来演示<code>main</code>方法执行的过程，希望能够帮助你理解：<br><img src="https://github.com/kinglaw1204/blogImage/blob/master/1+1%E7%90%86%E8%A7%A3%E5%AD%97%E8%8A%82%E7%A0%81/main%E6%96%B9%E6%B3%95gif.gif?raw=true" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章我从1+1的的源码编译开始，分析了生成后的Java字节码，包括类的基本信息，常量池，方法调用过程等，通过这些分析，我们对Java字节码有了比较基本的了解，也知道了Java编译器会把优化手段通过编译好的字节码体现出来，比如我们的1+1=2，字节码字节赋值一个2给变量，而不是进行加法运算，从而优化了我们的代码，提搞了执行效率。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://bugs.openjdk.java.net/browse/JDK-6527033" target="_blank" rel="noopener">https://bugs.openjdk.java.net/browse/JDK-6527033</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java 字节码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat中的容器是如何处理请求的</title>
      <link href="/2019/09/09/Tomcat-container/"/>
      <url>/2019/09/09/Tomcat-container/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2014/07/10/17/18/battleship-389274_1280.jpg" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇《<a href="[http://www.luozhou.top/2019/08/26/Tomcat%E4%B8%AD%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%9A%84/](http://www.luozhou.top/2019/08/26/Tomcat中的连接器是如何设计的/)">Tomcat中的连接器是如何设计的</a>》介绍了Tomcat中连接器的设计，我们知道连接器是负责监听网络端口，获取连接请求，然后转换符合Servlet标准的请求，交给容器去处理，那么我们这篇文章将顺着上一篇文章的思路，看看一个请求到了容器，容器是如何请求的。</p><blockquote><p>说明：本文tomcat版本是9.0.21，不建议零基础读者阅读。</p></blockquote><h2 id="从Adapter中说起"><a href="#从Adapter中说起" class="headerlink" title="从Adapter中说起"></a>从Adapter中说起</h2><p> 我们继续跟着上篇文章<code>Adapter</code>的源码，继续分析，上篇文章结尾的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F;源码1.类：  CoyoteAdapter implements Adapter</span><br><span class="line">public void service(org.apache.coyote.Request req, org.apache.coyote.Response res)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        Request request &#x3D; (Request) req.getNote(ADAPTER_NOTES);</span><br><span class="line">        Response response &#x3D; (Response) res.getNote(ADAPTER_NOTES);</span><br><span class="line">        postParseSuccess &#x3D; postParseRequest(req, request, res, response);</span><br><span class="line">            if (postParseSuccess) &#123;</span><br><span class="line">                &#x2F;&#x2F;check valves if we support async</span><br><span class="line">                request.setAsyncSupported(</span><br><span class="line">                        connector.getService().getContainer().getPipeline().isAsyncSupported());</span><br><span class="line">                &#x2F;&#x2F; Calling the container</span><br><span class="line">                connector.getService().getContainer().getPipeline().getFirst().invoke(</span><br><span class="line">                        request, response);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面的源码的主要作用就是获取到容器，然后调用<code>getPipeline()</code>获取<code>Pipeline</code>，最后去<code>invoke</code>调用，我们来看看这个<code>Pipeline</code>是做什么的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;源码2.Pipeline接口</span><br><span class="line">public interface Pipeline extends Contained &#123;</span><br><span class="line">  public Valve getBasic();</span><br><span class="line">  public void setBasic(Valve valve);</span><br><span class="line">  public void addValve(Valve valve);</span><br><span class="line">  public Valve[] getValves();</span><br><span class="line">  public void removeValve(Valve valve);</span><br><span class="line">  public Valve getFirst();</span><br><span class="line">  public boolean isAsyncSupported();</span><br><span class="line">  public void findNonAsyncValves(Set&lt;String&gt; result);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;源码3. Valve接口</span><br><span class="line">public interface Valve &#123;</span><br><span class="line"> public Valve getNext();</span><br><span class="line"> public void setNext(Valve valve);</span><br><span class="line"> public void backgroundProcess();</span><br><span class="line"> public void invoke(Request request, Response response)</span><br><span class="line">        throws IOException, ServletException;</span><br><span class="line"> public boolean isAsyncSupported();</span><br></pre></td></tr></table></figure><p>我们从字面上可以理解<code>Pipeline</code>就是管道，而<code>Valve</code>就是阀门，实际上在Tomcat中的作用也是和字面意思差不多。每个容器都有一个管道，而管道中又有多个阀门。我们通过后面的分析来证明这一点。</p><h2 id="管道-阀门（Pipeline-Valve）"><a href="#管道-阀门（Pipeline-Valve）" class="headerlink" title="管道-阀门（Pipeline-Valve）"></a>管道-阀门（Pipeline-Valve）</h2><p>我们看到上面的源码是<code>Pipeline</code>和<code>Valve</code>的接口，<code>Pipeline</code>主要是设置<code>Valve</code>,而<code>Valve</code>是一个链表，然后可以进行<code>invoke</code>方法的调用。我们回顾下这段源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;源码4</span><br><span class="line">connector.getService().getContainer().getPipeline().getFirst().invoke(</span><br><span class="line">                        request, response);</span><br></pre></td></tr></table></figure><p>这里是直接获取容器的管道，然后获取第一个<code>Valve</code>进行调用。我们在之前提到过<code>Valve</code>是一个链表，这里只调用第一个，也就是可以通过Next去调用到最后一个。我们再回顾下我们第一篇文章《<a href="https://my.oschina.net/luozhou/blog/3088908" target="_blank" rel="noopener">Tomcat在SpringBoot中是如何启动的</a>》中提到过，容器是分为4个子容器,分别为<code>Engine</code>、<code>Host</code>、<code>Context</code>、<code>Wrapper</code>,他们同时也是父级和子级的关系，<code>Engine</code>&gt;<code>Host</code>&gt;<code>Context</code>&gt;<code>Wrapper</code>。</p><p>我之前提到过，每个容器都一个<code>Pipeline</code>,那么这个是怎么体现出来的呢？我们看容器的接口源码就可以发现,<code>Pipeline</code>是容器接口定义的一个基本属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;源码5.</span><br><span class="line">public interface Container extends Lifecycle &#123;</span><br><span class="line">    &#x2F;&#x2F;省略其他代码</span><br><span class="line">  &#x2F;**</span><br><span class="line">     * Return the Pipeline object that manages the Valves associated with</span><br><span class="line">     * this Container.</span><br><span class="line">     *</span><br><span class="line">     * @return The Pipeline</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Pipeline getPipeline();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道了每个容器都有一个管道(<code>Pipeline</code>)，管道中有许多阀门(<code>Valve</code>),<code>Valve</code>可以进行链式调用，那么问题来了，父容器管道中的<code>Valve</code>怎么调用到子容器中的<code>Valve</code>呢？在<code>Pipeline</code>的实现类<code>StandardPipeline</code>中，我们发现了如下源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line">&#x2F;&#x2F; 源码6.</span><br><span class="line">     * The basic Valve (if any) associated with this Pipeline.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected Valve basic &#x3D; null;</span><br><span class="line">       &#x2F;**</span><br><span class="line">     * The first valve associated with this Pipeline.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected Valve first &#x3D; null;</span><br><span class="line">    </span><br><span class="line">     public void addValve(Valve valve) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;省略部分代码</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Add this Valve to the set associated with this Pipeline</span><br><span class="line">        if (first &#x3D;&#x3D; null) &#123;</span><br><span class="line">            first &#x3D; valve;</span><br><span class="line">            valve.setNext(basic);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Valve current &#x3D; first;</span><br><span class="line">            while (current !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;这里循环设置Valve，保证最后一个是basic</span><br><span class="line">                if (current.getNext() &#x3D;&#x3D; basic) &#123;</span><br><span class="line">                    current.setNext(valve);</span><br><span class="line">                    valve.setNext(basic);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                current &#x3D; current.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        container.fireContainerEvent(Container.ADD_VALVE_EVENT, valve);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>根据如上代码，我们知道了<code>basic</code>是一个管道(<code>Pipeline</code>)中的最后一个阀门，按道理只要最后一个阀门是下一个容器的第一个阀门就可以完成全部的链式调用了。我们用一个请求debug下看看是不是和我们的猜测一样，我们在<code>CoyoteAdapter</code>中的<code>service</code>方法中打个断点，效果如下：<br><img src="https://oscimg.oschina.net/oscnet/43675e6bc6e71eccb79755c82dac308c1db.jpg" alt=""></p><p>这里我们可以知道，在适配器调用容器的时候，也就是调用<code>Engine</code>的管道，只有一个阀门，也就是basic，值为<code>StandardEngineValve</code>。我们发现这个阀门的invoke方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;源码7.</span><br><span class="line">public final void invoke(Request request, Response response)</span><br><span class="line">        throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Select the Host to be used for this Request</span><br><span class="line">        Host host &#x3D; request.getHost();</span><br><span class="line">        if (host &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; HTTP 0.9 or HTTP 1.0 request without a host when no default host</span><br><span class="line">            &#x2F;&#x2F; is defined. This is handled by the CoyoteAdapter.</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (request.isAsyncSupported()) &#123;</span><br><span class="line">            request.setAsyncSupported(host.getPipeline().isAsyncSupported());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Ask this Host to process this request</span><br><span class="line">        host.getPipeline().getFirst().invoke(request, response);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们继续debug查看结果如下：<br><img src="https://oscimg.oschina.net/oscnet/4d8ccc43d0e35a4a78b052e50b2c07fc239.jpg" alt=""></p><p>所以这里的<code>basic</code>实际上将会调用到<code>Host</code>容器的管道(<code>Pipeline</code>)和阀门(<code>Valve</code>),也就是说，每个容器管道中的<code>basic</code>是负责调用下一个子容器的阀门。我用一张图来表示：</p><p><img src="https://oscimg.oschina.net/oscnet/3fddbf032d6391eb3035148d7ac00021d83.jpg" alt=""></p><p>这张图清晰的描述了，Tomcat内部的容器是如何流转请求的，从连接器（<code>Connector</code>）过来的请求会进入<code>Engine</code>容器，<code>Engine</code>通过管道(<code>Pieline</code>)中的阀门(<code>Valve</code>)来进行链式调用，最后的<code>basic</code>阀门是负责调用下一个容器的第一个阀门的，一直调用到<code>Wrapper</code>,然后<code>Wrapper</code>再执行<code>Servlet</code>。</p><p>我们看看<code>Wrapper</code>源码，是否真的如我们所说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;源码8.</span><br><span class="line"> public final void invoke(Request request, Response response)</span><br><span class="line">        throws IOException, ServletException &#123;</span><br><span class="line">            &#x2F;&#x2F;省略部分源码</span><br><span class="line">        Servlet servlet &#x3D; null;</span><br><span class="line">        if (!unavailable) &#123;</span><br><span class="line">            servlet &#x3D; wrapper.allocate();</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        &#x2F;&#x2F; Create the filter chain for this request</span><br><span class="line">        ApplicationFilterChain filterChain &#x3D;</span><br><span class="line">                ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);</span><br><span class="line">                </span><br><span class="line">         filterChain.doFilter(request.getRequest(),</span><br><span class="line">                                    response.getResponse());        </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>看到这里，你可能会说这里明明只是创建了过滤器(<code>Filter</code>)并且去调用而已，并没有去调用<code>Servlet</code><br>，没错，这里确实没有去调用<code>Servlet</code>，但是我们知道，过滤器(<code>Filter</code>)是在<code>Servlet</code>之前执行的，也就是说，<code>filterChain.doFilter</code>执行完之后变会执行<code>Servlet</code>。我们看看<code>ApplicationFilterChain</code>的源码是否如我们所说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;源码9.</span><br><span class="line"> public void doFilter(ServletRequest request, ServletResponse response)</span><br><span class="line">        throws IOException, ServletException &#123;</span><br><span class="line">        &#x2F;&#x2F;省略部分代码</span><br><span class="line">        internalDoFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;源码10.  </span><br><span class="line"> private void internalDoFilter(ServletRequest request,</span><br><span class="line">                                  ServletResponse response)</span><br><span class="line">        throws IOException, ServletException &#123;</span><br><span class="line">        &#x2F;&#x2F;省略部分代码</span><br><span class="line">        &#x2F;&#x2F; Call the next filter if there is one</span><br><span class="line">        if (pos &lt; n) &#123;</span><br><span class="line">         &#x2F;&#x2F;省略部分代码</span><br><span class="line">            ApplicationFilterConfig filterConfig &#x3D; filters[pos++];</span><br><span class="line">            Filter filter &#x3D; filterConfig.getFilter();</span><br><span class="line">            filter.doFilter(request, response, this);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;调用servlet</span><br><span class="line">        &#x2F;&#x2F; We fell off the end of the chain -- call the servlet instance</span><br><span class="line">        servlet.service(request, response);</span><br></pre></td></tr></table></figure><p>通过源码我们发现，在调用完所有的过滤器(<code>Filter</code>)之后，<code>servlet</code>就开始调用<code>service</code>。我们看看<code>servlet</code>的实现类</p><p><img src="https://oscimg.oschina.net/oscnet/6a8fc94c1d0c57f21efa2fea1aa8a3ca4c3.jpg" alt=""></p><p>这里我们熟悉的<code>HttpServlet</code>和<code>GenericServlet</code>是<code>Tomcat</code>包的类，实际上只有<code>HttpServlet</code>，因为<code>GenericServlet</code>是<code>HttpServlet</code>的父类。后面就是移交给了框架去处理了,Tomcat内部的请求已经到此是完成了。</p><h2 id="Tomcat的多应用隔离实现"><a href="#Tomcat的多应用隔离实现" class="headerlink" title="Tomcat的多应用隔离实现"></a>Tomcat的多应用隔离实现</h2><p>我们知道，Tomcat是支持部署多个应用的，那么Tomcat是如何支持多应用的部署呢？是怎么保证多个应用之间不会混淆的呢？要想弄懂这个问题，我们还是要回到适配器去说起，回到<code>service</code>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;源码11.类：CoyoteAdapter</span><br><span class="line">public void service(org.apache.coyote.Request req, org.apache.coyote.Response res)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">            &#x2F;&#x2F;省略部分代码</span><br><span class="line">            &#x2F;&#x2F; Parse and set Catalina and configuration specific</span><br><span class="line">            &#x2F;&#x2F; request parameters</span><br><span class="line">            &#x2F;&#x2F;处理URL映射</span><br><span class="line">            postParseSuccess &#x3D; postParseRequest(req, request, res, response);</span><br><span class="line">            if (postParseSuccess) &#123;</span><br><span class="line">                &#x2F;&#x2F;check valves if we support async</span><br><span class="line">                request.setAsyncSupported(</span><br><span class="line">                        connector.getService().getContainer().getPipeline().isAsyncSupported());</span><br><span class="line">                &#x2F;&#x2F; Calling the container</span><br><span class="line">                connector.getService().getContainer().getPipeline().getFirst().invoke(</span><br><span class="line">                        request, response);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在之前的源码中只谈到了<code>connector.getService().getContainer().getPipeline().getFirst().invoke( request, response)</code> 这段代码，这部分代码是调用容器，但是在调用容器之前有个<code>postParseRequest</code>方法是用来处理映射请求的，我们跟进看看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;源码12.类：CoyoteAdapter</span><br><span class="line"> protected boolean postParseRequest(org.apache.coyote.Request req, Request request,</span><br><span class="line">            org.apache.coyote.Response res, Response response) throws IOException, ServletException &#123;</span><br><span class="line">        省略部分代码</span><br><span class="line">        boolean mapRequired &#x3D; true;</span><br><span class="line">         while (mapRequired) &#123;</span><br><span class="line">            &#x2F;&#x2F; This will map the the latest version by default</span><br><span class="line">            connector.getService().getMapper().map(serverName, decodedURI,</span><br><span class="line">                    version, request.getMappingData());</span><br><span class="line">            &#x2F;&#x2F;没有找到上下文就报404错误        </span><br><span class="line">            if (request.getContext() &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; Don&#39;t overwrite an existing error</span><br><span class="line">                if (!response.isError()) &#123;</span><br><span class="line">                    response.sendError(404, &quot;Not found&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; Allow processing to continue.</span><br><span class="line">                &#x2F;&#x2F; If present, the error reporting valve will provide a response</span><br><span class="line">                &#x2F;&#x2F; body.</span><br><span class="line">                return true;</span><br><span class="line">            &#125;        </span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>这里就是循环去处理Url映射，如果<code>Context</code>没有找到，就返回404错误，我们继续看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;源码13.类：Mapper</span><br><span class="line">public void map(MessageBytes host, MessageBytes uri, String version,</span><br><span class="line">                    MappingData mappingData) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        if (host.isNull()) &#123;</span><br><span class="line">            String defaultHostName &#x3D; this.defaultHostName;</span><br><span class="line">            if (defaultHostName &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            host.getCharChunk().append(defaultHostName);</span><br><span class="line">        &#125;</span><br><span class="line">        host.toChars();</span><br><span class="line">        uri.toChars();</span><br><span class="line">        internalMap(host.getCharChunk(), uri.getCharChunk(), version, mappingData);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;源码14.类：Mapper</span><br><span class="line"> private final void internalMap(CharChunk host, CharChunk uri,</span><br><span class="line">            String version, MappingData mappingData) throws IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;省略部分代码</span><br><span class="line">        &#x2F;&#x2F; Virtual host mapping 处理Host映射</span><br><span class="line">        MappedHost[] hosts &#x3D; this.hosts;</span><br><span class="line">        MappedHost mappedHost &#x3D; exactFindIgnoreCase(hosts, host);</span><br><span class="line">      </span><br><span class="line">         &#x2F;&#x2F;省略部分代码</span><br><span class="line">        if (mappedHost &#x3D;&#x3D; null) &#123;</span><br><span class="line">             mappedHost &#x3D; defaultHost;</span><br><span class="line">            if (mappedHost &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        mappingData.host &#x3D; mappedHost.object;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; Context mapping 处理上下文映射</span><br><span class="line">        ContextList contextList &#x3D; mappedHost.contextList;</span><br><span class="line">        MappedContext[] contexts &#x3D; contextList.contexts;</span><br><span class="line">        &#x2F;&#x2F;省略部分代码</span><br><span class="line">        if (context &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        mappingData.context &#x3D; contextVersion.object;</span><br><span class="line">        mappingData.contextSlashCount &#x3D; contextVersion.slashCount;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Wrapper mapping 处理Servlet映射</span><br><span class="line">        if (!contextVersion.isPaused()) &#123;</span><br><span class="line">            internalMapWrapper(contextVersion, uri, mappingData);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由于上面的源码比较多，我省略了很多代码，保留了能理解主要逻辑的代码，总的来说就是处理Url包括三部分，映射<code>Host</code>，映射<code>Context</code>和映射<code>Servlet</code>(为了节省篇幅，具体细节源码请感兴趣的同学自行研究)。</p><p>这里我们可以发现一个细节，就是三个处理逻辑都是紧密关联的，只有<code>Host</code>不为空才会处理<code>Context</code>,对于<code>Servlet</code>也是同理。所以这里我们只要<code>Host</code>配置不同，那么后面所有的子容器都是不同的，也就完成了应用隔离的效果。但是对于SpringBoot内嵌Tomcat方式(使用jar包启动)来说，并不具备实现多应用的模式，本身一个应用就是一个Tomcat。</p><p>为了便于理解，我也画了一张多应用隔离的图，这里我们假设有两个域名<code>admin.luozhou.com</code>和<code>web.luozhou.com</code> 然后我每个域名下部署2个应用，分别是<code>User</code>,<code>log</code>,<code>blog</code>,<code>shop</code>。那么当我去想去添加用户的时候，我就会请求<code>admin.luozhou.com</code>域名下的<code>User</code>的<code>Context</code>下面的<code>add</code>的Servlet(<strong>说明：这里例子设计不符合实际开发原则，add这种粒度应该是框架中的controller完成，而不是Servlet</strong>)。</p><p><img src="https://oscimg.oschina.net/oscnet/bb89f9fbbaece649ff350e37a30854854ff.jpg" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章我们研究了Tomcat中容器是如何处理请求的，我们来回顾下内容：</p><ul><li>连接器把请求丢给适配器适配后调用容器(<code>Engine</code>)</li><li>容器内部是通过管道(<code>Pieline</code>)-阀门(<code>Valve</code>)模式完成容器的调用的,父容器调用子容器主要通过一个<code>basic</code>的阀门来完成的。</li><li>最后一个子容器<code>wrapper</code>完成调用后就会构建过滤器来进行过滤器调用，调用完成后就到了Tomcat内部的最后一步，调用servlet。也可以理解我们常用的<code>HttpServlet</code>，所有基于<code>Servlet</code>规范的框架在这里就进入了框架流程（包括SpringBoot）。</li><li>最后我们还分析了Tomcat是如何实现多应用隔离的，通过多应用的隔离分析，我们也明白了为什么Tomcat要设计如此多的子容器，多子容器可以根据需要完成不同粒度的隔离级别来实现不同的场景需求。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat中的连接器是如何设计的</title>
      <link href="/2019/08/26/Tomcat-connector/"/>
      <url>/2019/08/26/Tomcat-connector/</url>
      
        <content type="html"><![CDATA[<h2 id="上期回顾"><a href="#上期回顾" class="headerlink" title="上期回顾"></a>上期回顾</h2><p>上一篇文章《<a href="[http://www.luozhou.top/2020/02/28/Tomcat%E5%9C%A8SpringBoot%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8%E7%9A%84/](http://www.luozhou.top/2020/02/28/Tomcat在SpringBoot中是如何启动的/)">Tomcat在SpringBoot中是如何启动的</a>》从main方法启动说起，窥探了SpringBoot是如何启动Tomcat的，在分析Tomcat中我们重点提到了，Tomcat主要包括2个组件，连接器（Connector）和容器（Container）以及他们的内部结构图，那么今天我们来分析下Tomcat中的连接器是怎么设计的以及它的作用是什么。</p><blockquote><p>说明：本文tomcat版本是9.0.21，不建议零基础读者阅读。</p></blockquote><h2 id="从连接器（Connector）源码说起"><a href="#从连接器（Connector）源码说起" class="headerlink" title="从连接器（Connector）源码说起"></a>从连接器（Connector）源码说起</h2><p>既然是来解析连接器（Connector），那么我们直接从源码入手，后面所有源码我会剔除不重要部分，所以会忽略大部分源码细节，只关注流程。源码如下（高能预警，大量代码）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class Connector extends LifecycleMBeanBase  &#123;</span><br><span class="line">    public Connector() &#123;</span><br><span class="line">        this(&quot;org.apache.coyote.http11.Http11NioProtocol&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Connector(String protocol) &#123;</span><br><span class="line">        boolean aprConnector &#x3D; AprLifecycleListener.isAprAvailable() &amp;&amp;</span><br><span class="line">                AprLifecycleListener.getUseAprConnector();</span><br><span class="line"></span><br><span class="line">        if (&quot;HTTP&#x2F;1.1&quot;.equals(protocol) || protocol &#x3D;&#x3D; null) &#123;</span><br><span class="line">            if (aprConnector) &#123;</span><br><span class="line">                protocolHandlerClassName &#x3D; &quot;org.apache.coyote.http11.Http11AprProtocol&quot;;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                protocolHandlerClassName &#x3D; &quot;org.apache.coyote.http11.Http11NioProtocol&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (&quot;AJP&#x2F;1.3&quot;.equals(protocol)) &#123;</span><br><span class="line">            if (aprConnector) &#123;</span><br><span class="line">                protocolHandlerClassName &#x3D; &quot;org.apache.coyote.ajp.AjpAprProtocol&quot;;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                protocolHandlerClassName &#x3D; &quot;org.apache.coyote.ajp.AjpNioProtocol&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            protocolHandlerClassName &#x3D; protocol;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Instantiate protocol handler</span><br><span class="line">        ProtocolHandler p &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class&lt;?&gt; clazz &#x3D; Class.forName(protocolHandlerClassName);</span><br><span class="line">            p &#x3D; (ProtocolHandler) clazz.getConstructor().newInstance();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(sm.getString(</span><br><span class="line">                    &quot;coyoteConnector.protocolHandlerInstantiationFailed&quot;), e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            this.protocolHandler &#x3D; p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Default for Connector depends on this system property</span><br><span class="line">        setThrowOnFailure(Boolean.getBoolean(&quot;org.apache.catalina.startup.EXIT_ON_INIT_FAILURE&quot;));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们来看看Connector的构造方法，其实只做了一件事情，就是根据协议设置对应的<code>ProtocolHandler</code>,根据名称我们知道，这是协议处理类，所以连接器内部的一个重要子模块就是<code>ProtocolHandler</code>。</p><h2 id="关于生命周期"><a href="#关于生命周期" class="headerlink" title="关于生命周期"></a>关于生命周期</h2><p>我们看到<code>Connector</code>继承了<code>LifecycleMBeanBase</code>，我们来看看<code>Connector</code>的最终继承关系：</p><p><img src="https://oscimg.oschina.net/oscnet/ae9d2b25d9cb3152a50368bb07a4d73933d.jpg" alt=""></p><p>我们看到最终实现的是<code>Lifecycle</code>接口,我们看看这个接口是何方神圣。我把其接口的注释拿下来解释下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Common interface for component life cycle methods.  Catalina components</span><br><span class="line"> * may implement this interface (as well as the appropriate interface(s) for</span><br><span class="line"> * the functionality they support) in order to provide a consistent mechanism</span><br><span class="line"> * to start and stop the component.</span><br><span class="line"> *            start()</span><br><span class="line"> *  -----------------------------</span><br><span class="line"> *  |                           |</span><br><span class="line"> *  | init()                    |</span><br><span class="line"> * NEW -»-- INITIALIZING        |</span><br><span class="line"> * | |           |              |     ------------------«-----------------------</span><br><span class="line"> * | |           |auto          |     |                                        |</span><br><span class="line"> * | |          \|&#x2F;    start() \|&#x2F;   \|&#x2F;     auto          auto         stop() |</span><br><span class="line"> * | |      INITIALIZED --»-- STARTING_PREP --»- STARTING --»- STARTED --»---  |</span><br><span class="line"> * | |         |                                                            |  |</span><br><span class="line"> * | |destroy()|                                                            |  |</span><br><span class="line"> * | --»-----«--    ------------------------«--------------------------------  ^</span><br><span class="line"> * |     |          |                                                          |</span><br><span class="line"> * |     |         \|&#x2F;          auto                 auto              start() |</span><br><span class="line"> * |     |     STOPPING_PREP ----»---- STOPPING ------»----- STOPPED -----»-----</span><br><span class="line"> * |    \|&#x2F;                               ^                     |  ^</span><br><span class="line"> * |     |               stop()           |                     |  |</span><br><span class="line"> * |     |       --------------------------                     |  |</span><br><span class="line"> * |     |       |                                              |  |</span><br><span class="line"> * |     |       |    destroy()                       destroy() |  |</span><br><span class="line"> * |     |    FAILED ----»------ DESTROYING ---«-----------------  |</span><br><span class="line"> * |     |                        ^     |                          |</span><br><span class="line"> * |     |     destroy()          |     |auto                      |</span><br><span class="line"> * |     --------»-----------------    \|&#x2F;                         |</span><br><span class="line"> * |                                 DESTROYED                     |</span><br><span class="line"> * |                                                               |</span><br><span class="line"> * |                            stop()                             |</span><br><span class="line"> * ----»-----------------------------»------------------------------</span><br><span class="line"> *</span><br><span class="line"> * Any state can transition to FAILED.</span><br><span class="line"> *</span><br><span class="line"> * Calling start() while a component is in states STARTING_PREP, STARTING or</span><br><span class="line"> * STARTED has no effect.</span><br><span class="line"> *</span><br><span class="line"> * Calling start() while a component is in state NEW will cause init() to be</span><br><span class="line"> * called immediately after the start() method is entered.</span><br><span class="line"> *</span><br><span class="line"> * Calling stop() while a component is in states STOPPING_PREP, STOPPING or</span><br><span class="line"> * STOPPED has no effect.</span><br><span class="line"> *</span><br><span class="line"> * Calling stop() while a component is in state NEW transitions the component</span><br><span class="line"> * to STOPPED. This is typically encountered when a component fails to start and</span><br><span class="line"> * does not start all its sub-components. When the component is stopped, it will</span><br><span class="line"> * try to stop all sub-components - even those it didn&#39;t start.</span><br><span class="line"> *</span><br><span class="line"> * Attempting any other transition will throw &#123;@link LifecycleException&#125;.</span><br><span class="line"> *</span><br><span class="line"> * &lt;&#x2F;pre&gt;</span><br><span class="line"> * The &#123;@link LifecycleEvent&#125;s fired during state changes are defined in the</span><br><span class="line"> * methods that trigger the changed. No &#123;@link LifecycleEvent&#125;s are fired if the</span><br><span class="line"> * attempted transition is not valid.</span><br></pre></td></tr></table></figure><p>这段注释翻译就是，这个接口是提供给组件声明周期管理的，并且提供了声明周期流转图。这里我们只需要知道正常流程即可：</p><blockquote><p>New—&gt;Init()—-&gt;Start()—-&gt;Stop()—&gt;Destory()</p></blockquote><h2 id="从生命周期探索连接器"><a href="#从生命周期探索连接器" class="headerlink" title="从生命周期探索连接器"></a>从生命周期探索连接器</h2><p>根据上面的生命周期说明，我们可以知道连接器（<code>Connector</code>）就是按照如此的声明周期管理的，所以我们找到了线索，所以连接器肯定会先初始化然后再启动。我们查看其<code>initInternal()</code>方法可以知道连接器初始化做了什么事情，源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">    @Override</span><br><span class="line">    protected void initInternal() throws LifecycleException &#123;</span><br><span class="line"></span><br><span class="line">        super.initInternal();</span><br><span class="line"></span><br><span class="line">        if (protocolHandler &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new LifecycleException(</span><br><span class="line">                    sm.getString(&quot;coyoteConnector.protocolHandlerInstantiationFailed&quot;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Initialize adapter</span><br><span class="line">        adapter &#x3D; new CoyoteAdapter(this);</span><br><span class="line">        protocolHandler.setAdapter(adapter);</span><br><span class="line">        if (service !&#x3D; null) &#123;</span><br><span class="line">            protocolHandler.setUtilityExecutor(service.getServer().getUtilityExecutor());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Make sure parseBodyMethodsSet has a default</span><br><span class="line">        if (null &#x3D;&#x3D; parseBodyMethodsSet) &#123;</span><br><span class="line">            setParseBodyMethods(getParseBodyMethods());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (protocolHandler.isAprRequired() &amp;&amp; !AprLifecycleListener.isInstanceCreated()) &#123;</span><br><span class="line">            throw new LifecycleException(sm.getString(&quot;coyoteConnector.protocolHandlerNoAprListener&quot;,</span><br><span class="line">                    getProtocolHandlerClassName()));</span><br><span class="line">        &#125;</span><br><span class="line">        if (protocolHandler.isAprRequired() &amp;&amp; !AprLifecycleListener.isAprAvailable()) &#123;</span><br><span class="line">            throw new LifecycleException(sm.getString(&quot;coyoteConnector.protocolHandlerNoAprLibrary&quot;,</span><br><span class="line">                    getProtocolHandlerClassName()));</span><br><span class="line">        &#125;</span><br><span class="line">        if (AprLifecycleListener.isAprAvailable() &amp;&amp; AprLifecycleListener.getUseOpenSSL() &amp;&amp;</span><br><span class="line">                protocolHandler instanceof AbstractHttp11JsseProtocol) &#123;</span><br><span class="line">            AbstractHttp11JsseProtocol&lt;?&gt; jsseProtocolHandler &#x3D;</span><br><span class="line">                    (AbstractHttp11JsseProtocol&lt;?&gt;) protocolHandler;</span><br><span class="line">            if (jsseProtocolHandler.isSSLEnabled() &amp;&amp;</span><br><span class="line">                    jsseProtocolHandler.getSslImplementationName() &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; OpenSSL is compatible with the JSSE configuration, so use it if APR is available</span><br><span class="line">                jsseProtocolHandler.setSslImplementationName(OpenSSLImplementation.class.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            protocolHandler.init();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new LifecycleException(</span><br><span class="line">                    sm.getString(&quot;coyoteConnector.protocolHandlerInitializationFailed&quot;), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面源码，我们发现主要是处理<code>protocolHandler</code>并初始化它，同时我们注意到了<code>protocolHandler</code> 设置了一个适配器，我们看看这个适配器是做啥的，跟踪源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  * The adapter, used to call the connector.</span><br><span class="line">  *</span><br><span class="line">  * @param adapter The adapter to associate</span><br><span class="line">  *&#x2F;</span><br><span class="line"> public void setAdapter(Adapter adapter);</span><br></pre></td></tr></table></figure><p>这个注释已经说的很直白了，这个适配器就是用来调用连接器的。我们再继续看看<code>protocolHandler</code>的初始化方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line">     * Endpoint that provides low-level network I&#x2F;O - must be matched to the</span><br><span class="line">     * ProtocolHandler implementation (ProtocolHandler using NIO, requires NIO</span><br><span class="line">     * Endpoint etc.).</span><br><span class="line">     *&#x2F;</span><br><span class="line">private final AbstractEndpoint&lt;S,?&gt; endpoint;</span><br><span class="line"></span><br><span class="line">public void init() throws Exception &#123;</span><br><span class="line">        if (getLog().isInfoEnabled()) &#123;</span><br><span class="line">            getLog().info(sm.getString(&quot;abstractProtocolHandler.init&quot;, getName()));</span><br><span class="line">            logPortOffset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (oname &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; Component not pre-registered so register it</span><br><span class="line">            oname &#x3D; createObjectName();</span><br><span class="line">            if (oname !&#x3D; null) &#123;</span><br><span class="line">                Registry.getRegistry(null, null).registerComponent(this, oname, null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (this.domain !&#x3D; null) &#123;</span><br><span class="line">            rgOname &#x3D; new ObjectName(domain + &quot;:type&#x3D;GlobalRequestProcessor,name&#x3D;&quot; + getName());</span><br><span class="line">            Registry.getRegistry(null, null).registerComponent(</span><br><span class="line">                    getHandler().getGlobal(), rgOname, null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String endpointName &#x3D; getName();</span><br><span class="line">        endpoint.setName(endpointName.substring(1, endpointName.length()-1));</span><br><span class="line">        endpoint.setDomain(domain);</span><br><span class="line"></span><br><span class="line">        endpoint.init();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里出现了一个新的对象，<code>endpoint</code>,根据注释我们可以知道<code>endpoint</code>是用来处理网络IO的，而且必须匹配到指定的子类（比如Nio,就是NioEndPoint处理）。<code>endpoint.init()</code>实际上就是做一些网络的配置，然后就是初始化完毕了。根据我们上面的周期管理，我们知道<code>init()</code>后就是<code>start()</code>,所以我们查看<code>Connector</code>的<code>start()</code>源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protected void startInternal() throws LifecycleException &#123;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; Validate settings before starting</span><br><span class="line">       if (getPortWithOffset() &lt; 0) &#123;</span><br><span class="line">           throw new LifecycleException(sm.getString(</span><br><span class="line">                   &quot;coyoteConnector.invalidPort&quot;, Integer.valueOf(getPortWithOffset())));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       setState(LifecycleState.STARTING);</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">           protocolHandler.start();</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           throw new LifecycleException(</span><br><span class="line">                   sm.getString(&quot;coyoteConnector.protocolHandlerStartFailed&quot;), e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>其实就是主要调用<code>protocolHandler.start()</code>方法，继续跟踪，为了方便表述，我会把接下来的代码统一放在一起说明，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1.类：AbstractProtocol implements ProtocolHandler,</span><br><span class="line">        MBeanRegistration</span><br><span class="line"> public void start() throws Exception &#123;</span><br><span class="line">     &#x2F;&#x2F; 省略部分代码</span><br><span class="line">    endpoint.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2. 类：AbstractEndPoint   </span><br><span class="line">public final void start() throws Exception &#123;</span><br><span class="line">       &#x2F;&#x2F; 省略部分代码</span><br><span class="line">        startInternal();</span><br><span class="line">    &#125;</span><br><span class="line"> &#x2F;**3.类：NioEndPoint extends AbstractJsseEndpoint&lt;NioChannel,SocketChannel&gt;</span><br><span class="line">     * Start the NIO endpoint, creating acceptor, poller threads.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void startInternal() throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;省略部分代码</span><br><span class="line">       </span><br><span class="line">            &#x2F;&#x2F; Start poller thread</span><br><span class="line">            poller &#x3D; new Poller();</span><br><span class="line">            Thread pollerThread &#x3D; new Thread(poller, getName() + &quot;-ClientPoller&quot;);</span><br><span class="line">            pollerThread.setPriority(threadPriority);</span><br><span class="line">            pollerThread.setDaemon(true);</span><br><span class="line">            pollerThread.start();</span><br><span class="line"></span><br><span class="line">            startAcceptorThread();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到这里，其实整个启动代码就完成了，我们看到最后是在<code>NioEndPoint</code>创建了一个<code>Poller</code>,并且启动它，这里需要补充说明下，这里只是以NioEndPoint为示列，其实Tomcat 主要提供了三种实现，分别是<code>AprEndPoint</code>,<code>NioEndPoint</code>,<code>Nio2EndPoint</code>,这里表示了tomcat支持的I/O模型：</p><blockquote><p>APR:采用 Apache 可移植运行库实现,它根据不同操作系统，分别用c重写了大部分IO和系统线程操作模块,据说性能要比其他模式要好（未实测）。</p></blockquote><blockquote><p>NIO：非阻塞 I/O </p></blockquote><blockquote><p>NIO.2：异步 I/O</p></blockquote><p>上述代码主要是开启两个线程，一个是Poller,一个是开启Acceptor，既然是线程，核心的代码肯定是<code>run方法</code>，我们来查看源码，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;4.类：Acceptor&lt;U&gt; implements Runnable</span><br><span class="line"> public void run() &#123;</span><br><span class="line"> &#x2F;&#x2F;省略了部分代码</span><br><span class="line">                U socket &#x3D; null;</span><br><span class="line">                    socket &#x3D; endpoint.serverSocketAccept();</span><br><span class="line">                &#x2F;&#x2F; Configure the socket</span><br><span class="line">                if (endpoint.isRunning() &amp;&amp; !endpoint.isPaused()) &#123;</span><br><span class="line">                    &#x2F;&#x2F; setSocketOptions() will hand the socket off to</span><br><span class="line">                    &#x2F;&#x2F; an appropriate processor if successful</span><br><span class="line">                    &#x2F;&#x2F;核心逻辑</span><br><span class="line">                    if (!endpoint.setSocketOptions(socket)) &#123;</span><br><span class="line">                        endpoint.closeSocket(socket);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    endpoint.destroySocket(socket);</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">        state &#x3D; AcceptorState.ENDED;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;5.类：NioEndpoint</span><br><span class="line">protected boolean setSocketOptions(SocketChannel socket) &#123;</span><br><span class="line">        &#x2F;&#x2F; Process the connection</span><br><span class="line">        &#x2F;&#x2F;省略部分代码</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; Disable blocking, polling will be used</span><br><span class="line">            socket.configureBlocking(false);</span><br><span class="line">            Socket sock &#x3D; socket.socket();</span><br><span class="line">            socketProperties.setProperties(sock);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            NioSocketWrapper socketWrapper &#x3D; new NioSocketWrapper(channel, this);</span><br><span class="line">            channel.setSocketWrapper(socketWrapper);</span><br><span class="line">            socketWrapper.setReadTimeout(getConnectionTimeout());</span><br><span class="line">            socketWrapper.setWriteTimeout(getConnectionTimeout());</span><br><span class="line">            socketWrapper.setKeepAliveLeft(NioEndpoint.this.getMaxKeepAliveRequests());</span><br><span class="line">            socketWrapper.setSecure(isSSLEnabled());</span><br><span class="line">            &#x2F;&#x2F;核心逻辑</span><br><span class="line">            poller.register(channel, socketWrapper);</span><br><span class="line">            return true;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里可以发现<code>Acceptor</code>主要就是接受<code>socket</code>,然后把它注册到<code>poller</code>中，我们继续看看是如何注册的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**6.类NioEndpoint</span><br><span class="line">         * Registers a newly created socket with the poller.</span><br><span class="line">         *</span><br><span class="line">         * @param socket    The newly created socket</span><br><span class="line">         * @param socketWrapper The socket wrapper</span><br><span class="line">         *&#x2F;</span><br><span class="line">        public void register(final NioChannel socket, final NioSocketWrapper socketWrapper) &#123;</span><br><span class="line">            socketWrapper.interestOps(SelectionKey.OP_READ);&#x2F;&#x2F;this is what OP_REGISTER turns into.</span><br><span class="line">            PollerEvent r &#x3D; null;</span><br><span class="line">            if (eventCache !&#x3D; null) &#123;</span><br><span class="line">                r &#x3D; eventCache.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            if (r &#x3D;&#x3D; null) &#123;</span><br><span class="line">                r &#x3D; new PollerEvent(socket, OP_REGISTER);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                r.reset(socket, OP_REGISTER);</span><br><span class="line">            &#125;</span><br><span class="line">            addEvent(r);</span><br><span class="line">        &#125;</span><br><span class="line">&#x2F;** 7.类：PollerEvent implements Runnable</span><br><span class="line"> public void run() &#123;</span><br><span class="line">    &#x2F;&#x2F;省略部分代码</span><br><span class="line">    socket.getIOChannel().register(socket.getSocketWrapper().getPoller().getSelector(), SelectionKey.OP_READ, socket.getSocketWrapper());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p> 这里发现最终就是采用NIO模型把其注册到通道中。(这里涉及NIO网络编程知识，不了解的同学可以传送<a href="http://ifeve.com/java-nio-all/" target="_blank" rel="noopener">这里</a>)。那么注册完毕后，我们看看Poller做了什么事情。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">*&#x2F;        </span><br><span class="line">  &#x2F;**8.类：NioEndPoint内部类 Poller implements Runnable</span><br><span class="line">  **&#x2F;  </span><br><span class="line">  @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            &#x2F;&#x2F; Loop until destroy() is called</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                &#x2F;&#x2F;省略部分代码</span><br><span class="line"></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator &#x3D;</span><br><span class="line">                    keyCount &gt; 0 ? selector.selectedKeys().iterator() : null;</span><br><span class="line">                &#x2F;&#x2F; Walk through the collection of ready keys and dispatch</span><br><span class="line">                &#x2F;&#x2F; any active event.</span><br><span class="line">                while (iterator !&#x3D; null &amp;&amp; iterator.hasNext()) &#123;</span><br><span class="line">                    SelectionKey sk &#x3D; iterator.next();</span><br><span class="line">                    NioSocketWrapper socketWrapper &#x3D; (NioSocketWrapper) sk.attachment();</span><br><span class="line">                    &#x2F;&#x2F; Attachment may be null if another thread has called</span><br><span class="line">                    &#x2F;&#x2F; cancelledKey()</span><br><span class="line">                    if (socketWrapper &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                        &#x2F;&#x2F;sock处理</span><br><span class="line">                        processKey(sk, socketWrapper);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#x2F;&#x2F;省略部分代码</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p> 这个就是通过selector把之前注册的事件取出来，从而完成了调用。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F;9.类： NioEndPoint内部类 Poller  implements Runnable     </span><br><span class="line"> protected void processKey(SelectionKey sk, NioSocketWrapper socketWrapper) &#123;</span><br><span class="line">          &#x2F;&#x2F;省略大部分代码</span><br><span class="line">            processSocket(socketWrapper, SocketEvent.OPEN_WRITE, true)</span><br><span class="line">     </span><br><span class="line"> &#125;</span><br><span class="line">        </span><br><span class="line"> &#x2F;&#x2F;10.类：AbstractEndPoint        </span><br><span class="line"> public boolean processSocket(SocketWrapperBase&lt;S&gt; socketWrapper,</span><br><span class="line">            SocketEvent event, boolean dispatch) &#123;</span><br><span class="line">        &#x2F;&#x2F;省略部分代码</span><br><span class="line">            Executor executor &#x3D; getExecutor();</span><br><span class="line">            if (dispatch &amp;&amp; executor !&#x3D; null) &#123;</span><br><span class="line">                executor.execute(sc);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                sc.run();</span><br><span class="line">            &#125;</span><br><span class="line">       </span><br><span class="line">        return true;</span><br><span class="line">    &#125;  </span><br><span class="line"> &#x2F;&#x2F;11.类：SocketProcessorBase  implements Runnable   </span><br><span class="line">public final void run() &#123;</span><br><span class="line">        synchronized (socketWrapper) &#123;</span><br><span class="line">            &#x2F;&#x2F; It is possible that processing may be triggered for read and</span><br><span class="line">            &#x2F;&#x2F; write at the same time. The sync above makes sure that processing</span><br><span class="line">            &#x2F;&#x2F; does not occur in parallel. The test below ensures that if the</span><br><span class="line">            &#x2F;&#x2F; first event to be processed results in the socket being closed,</span><br><span class="line">            &#x2F;&#x2F; the subsequent events are not processed.</span><br><span class="line">            if (socketWrapper.isClosed()) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            doRun();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;类：12.NioEndPoint   extends AbstractJsseEndpoint&lt;NioChannel,SocketChannel&gt; </span><br><span class="line">protected void doRun() &#123;</span><br><span class="line">        &#x2F;&#x2F;省略部分代码</span><br><span class="line">                if (handshake &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    SocketState state &#x3D; SocketState.OPEN;</span><br><span class="line">                    &#x2F;&#x2F; Process the request from this socket</span><br><span class="line">                    if (event &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        state &#x3D; getHandler().process(socketWrapper, SocketEvent.OPEN_READ);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        state &#x3D; getHandler().process(socketWrapper, event);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (state &#x3D;&#x3D; SocketState.CLOSED) &#123;</span><br><span class="line">                        poller.cancelledKey(key, socketWrapper);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><br><code>Poller</code>调用的<code>run</code>方法或者用Executor线程池去执行<code>run()</code>,最终调用都是各个子<code>EndPoint</code>中的<code>doRun()</code>方法，最终会取一个<code>Handler</code>去处理<code>socketWrapper</code>。继续看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;类：13.AbstractProtocol内部类ConnectionHandler implements AbstractEndpoint.Handler&lt;S&gt;</span><br><span class="line"> public SocketState process(SocketWrapperBase&lt;S&gt; wrapper, SocketEvent status) &#123;</span><br><span class="line">            &#x2F;&#x2F;省略部分代码</span><br><span class="line">    </span><br><span class="line">            state &#x3D; processor.process(wrapper, status);</span><br><span class="line">      </span><br><span class="line">            return SocketState.CLOSED;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">&#x2F;&#x2F;类：14.AbstractProcessorLight implements Processor </span><br><span class="line">public SocketState process(SocketWrapperBase&lt;?&gt; socketWrapper, SocketEvent status)</span><br><span class="line">            throws IOException &#123;</span><br><span class="line">            &#x2F;&#x2F;省略部分代码</span><br><span class="line">           </span><br><span class="line">            state &#x3D; service(socketWrapper);</span><br><span class="line">            </span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 这部分源码表明最终调用的process是通过一个<code>Processor</code>接口的实现类来完成的，这里最终也是会调用到各个子类中，那么这里的处理器其实就是处理应用协议，我们可以查看<code>AbstractProcessorLight</code>的实现类，分别有<code>AjpProcessor</code>、<code>Http11Processor</code>、<code>StreamProcessor</code>，分别代表tomcat支持三种应用层协议，分别是：</p><ul><li><p><a href="https://baike.baidu.com/item/ajp" target="_blank" rel="noopener">AJP</a>协议</p></li><li><p><a href="https://baike.baidu.com/item/HTTP1.1" target="_blank" rel="noopener">HTTP.1</a>协议</p></li><li><p><a href="https://baike.baidu.com/item/HTTP%202.0/12520156" target="_blank" rel="noopener">HTTP2.0</a>协议</p><p>这里我们以常用的HTTP1.1为例，继续看源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;类：15. Http11Processor extends AbstractProcessor</span><br><span class="line">public SocketState service(SocketWrapperBase&lt;?&gt; socketWrapper)</span><br><span class="line">        throws IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;省略大部分代码</span><br><span class="line">             getAdapter().service(request, response);</span><br><span class="line">        &#x2F;&#x2F;省略大部分代码   </span><br><span class="line">        &#125; </span><br><span class="line">&#x2F;&#x2F;类：16   CoyoteAdapter implements Adapter</span><br><span class="line">public void service(org.apache.coyote.Request req, org.apache.coyote.Response res)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        Request request &#x3D; (Request) req.getNote(ADAPTER_NOTES);</span><br><span class="line">        Response response &#x3D; (Response) res.getNote(ADAPTER_NOTES);</span><br><span class="line">        postParseSuccess &#x3D; postParseRequest(req, request, res, response);</span><br><span class="line">            if (postParseSuccess) &#123;</span><br><span class="line">                &#x2F;&#x2F;check valves if we support async</span><br><span class="line">                request.setAsyncSupported(</span><br><span class="line">                        connector.getService().getContainer().getPipeline().isAsyncSupported());</span><br><span class="line">                &#x2F;&#x2F; Calling the container</span><br><span class="line">                connector.getService().getContainer().getPipeline().getFirst().invoke(</span><br><span class="line">                        request, response);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>这里我们发现协议处理器最终会调用适配器(<code>CoyoteAdapter</code>),而适配器最终的工作是转换<code>Request</code>和<code>Response</code>对象为<code>HttpServletRequest</code>和<code>HttpServletResponse</code>，从而可以去调用容器，到这里整个连接器的流程和作用我们就已经分析完了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>那么我们来回忆下整个流程，我画了一张时序图来说明：</p><p><img src="https://oscimg.oschina.net/oscnet/37fa4be5dee49b110cb25d45d18fde45446.jpg" alt=""></p><p>这张图包含了两个流程，一个是组件的初始化，一个是调用的流程。连接器(Connector)主要初始化了两个组件，<code>ProtcoHandler</code>和<code>EndPoint</code>,但是我们从代码结构发现，他们两个是父子关系，也就是说<code>ProtcoHandler</code>包含了<code>EndPoint</code>。后面的流程就是各个子组件的调用链关系，总结来说就是<code>Acceptor</code>负责接收请求，然后注册到<code>Poller</code>，<code>Poller</code>负责处理请求，然后调用<code>processor</code>处理器来处理，最后把请求转成符合<code>Servlet</code>规范的<code>request</code>和<code>response</code>去调用容器(<code>Container</code>)。</p><p>我们流程梳理清楚了，接下来我们来结构化的梳理下：</p><p>回到连接器（<code>Connector</code>）是源码，我们发现，上述说的模块只有<code>ProtocolHandler</code>和<code>Adapter</code>两个属于连接器中，也就是说，连接器只包含了这两大子模块，那么后续的<code>EndPoint</code>、<code>Acceptor</code>、<code>Poller</code>、<code>Processor</code>都是<code>ProtocolHandler</code>的子模块。<br>而<code>Acceptor</code>和<code>Poller</code>两个模块的核心功能都是在<code>EndPoint</code> 中完成的，所以是其子模块，而<code>Processor</code>比较独立，所以它和<code>EndPoint</code>是一个级别的子模块。</p><p>我们用图来说明下上述的关系：</p><p><img src="https://oscimg.oschina.net/oscnet/4fab510013fd7507250dd26898915d10284.jpg" alt=""></p><p>根据上图我们可以知道，连接器主要负责处理连接请求，然后通过适配器调用容器。那么具体流程细化可以如下：</p><ul><li><code>Acceptor</code>监听网络请求，获取请求。</li><li><code>Poller</code>获取到监听的请求提交线程池进行处理。</li><li><code>Processor</code>根据具体的应用协议（HTTP/AJP）来生成Tomcat Request对象。</li><li><code>Adapter</code>把Request对象转换成Servlet标准的Request对象，调用容器。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们从连接器的源码，一步一步解析，分析了连接器主要包含了两大模块，<code>ProtocolHandler</code>和<code>Adapter</code>。<code>ProtocolHandler</code>主要包含了<code>Endpoint</code>模块和<code>Processor</code>模块。<code>Endpoint</code>模块主要的作用是连接的处理，它委托了<code>Acceptor</code>子模块进行连接的监听和注册,委托子模块<code>Poller</code>进行连接的处理；而<code>Processor</code>模块主要是应用协议的处理，最后提交给<code>Adapter</code>进行对象的转换，以便可以调用容器(Container)。另外我们也在分析源码的过程中补充了一些额外知识点：</p><ul><li>当前Tomcat版本支持的IO模型为：APR模型、NIO模型、NIO.2模型</li><li>Tomcat支持的协议是AJP和HTTP,其中HTTP又分为HTTP1.1和HTTP2.0</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat在SpringBoot中是如何启动的</title>
      <link href="/2019/08/12/Tomcat-start-in-springboot/"/>
      <url>/2019/08/12/Tomcat-start-in-springboot/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.pixabay.com/photo/2017/09/29/11/57/cat-2798804_1280.png" alt="image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们知道SpringBoot给我们带来了一个全新的开发体验，我们可以直接把web程序达成jar包，直接启动，这就得益于SpringBoot内置了容器，可以直接启动，本文将以Tomcat为例，来看看SpringBoot是如何启动Tomcat的，同时也将展开学习下Tomcat的源码，了解Tomcat的设计。</p><h2 id="从-Main-方法说起"><a href="#从-Main-方法说起" class="headerlink" title="从 Main 方法说起"></a>从 Main 方法说起</h2><p>用过SpringBoot的人都知道，首先要写一个main方法来启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class TomcatdebugApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(TomcatdebugApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们直接点击run方法的源码，跟踪下来，发下最终 的<code>run</code>方法是调用<code>ConfigurableApplicationContext</code>方法，源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public ConfigurableApplicationContext run(String... args) &#123;</span><br><span class="line">StopWatch stopWatch &#x3D; new StopWatch();</span><br><span class="line">stopWatch.start();</span><br><span class="line">ConfigurableApplicationContext context &#x3D; null;</span><br><span class="line">Collection&lt;springbootexceptionreporter&gt; exceptionReporters &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">&#x2F;&#x2F;设置系统属性『java.awt.headless』，为true则启用headless模式支持</span><br><span class="line">configureHeadlessProperty();</span><br><span class="line">&#x2F;&#x2F;通过*SpringFactoriesLoader*检索*META-INF&#x2F;spring.factories*，</span><br><span class="line">       &#x2F;&#x2F;找到声明的所有SpringApplicationRunListener的实现类并将其实例化，</span><br><span class="line">       &#x2F;&#x2F;之后逐个调用其started()方法，广播SpringBoot要开始执行了</span><br><span class="line">SpringApplicationRunListeners listeners &#x3D; getRunListeners(args);</span><br><span class="line">&#x2F;&#x2F;发布应用开始启动事件</span><br><span class="line">listeners.starting();</span><br><span class="line">try &#123;</span><br><span class="line">&#x2F;&#x2F;初始化参数</span><br><span class="line">ApplicationArguments applicationArguments &#x3D; new DefaultApplicationArguments(args);</span><br><span class="line">&#x2F;&#x2F;创建并配置当前SpringBoot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）,</span><br><span class="line">        &#x2F;&#x2F;并遍历调用所有的SpringApplicationRunListener的environmentPrepared()方法，广播Environment准备完毕。</span><br><span class="line">ConfigurableEnvironment environment &#x3D; prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">configureIgnoreBeanInfo(environment);</span><br><span class="line">&#x2F;&#x2F;打印banner</span><br><span class="line">Banner printedBanner &#x3D; printBanner(environment);</span><br><span class="line">&#x2F;&#x2F;创建应用上下文</span><br><span class="line">context &#x3D; createApplicationContext();</span><br><span class="line">&#x2F;&#x2F;通过*SpringFactoriesLoader*检索*META-INF&#x2F;spring.factories*，获取并实例化异常分析器</span><br><span class="line">exceptionReporters &#x3D; getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line">new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">&#x2F;&#x2F;为ApplicationContext加载environment，之后逐个执行ApplicationContextInitializer的initialize()方法来进一步封装ApplicationContext，</span><br><span class="line">        &#x2F;&#x2F;并调用所有的SpringApplicationRunListener的contextPrepared()方法，【EventPublishingRunListener只提供了一个空的contextPrepared()方法】，</span><br><span class="line">        &#x2F;&#x2F;之后初始化IoC容器，并调用SpringApplicationRunListener的contextLoaded()方法，广播ApplicationContext的IoC加载完成，</span><br><span class="line">        &#x2F;&#x2F;这里就包括通过**@EnableAutoConfiguration**导入的各种自动配置类。</span><br><span class="line">prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">&#x2F;&#x2F;刷新上下文</span><br><span class="line">refreshContext(context);</span><br><span class="line">&#x2F;&#x2F;再一次刷新上下文,其实是空方法，可能是为了后续扩展。</span><br><span class="line">afterRefresh(context, applicationArguments);</span><br><span class="line">stopWatch.stop();</span><br><span class="line">if (this.logStartupInfo) &#123;</span><br><span class="line">new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;发布应用已经启动的事件</span><br><span class="line">listeners.started(context);</span><br><span class="line">&#x2F;&#x2F;遍历所有注册的ApplicationRunner和CommandLineRunner，并执行其run()方法。</span><br><span class="line">        &#x2F;&#x2F;我们可以实现自己的ApplicationRunner或者CommandLineRunner，来对SpringBoot的启动过程进行扩展。</span><br><span class="line">callRunners(context, applicationArguments);</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">throw new IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">&#x2F;&#x2F;应用已经启动完成的监听事件</span><br><span class="line">listeners.running(context);</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, null);</span><br><span class="line">throw new IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line">return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这个方法我们可以简单的总结下步骤为<br>&gt;  1. 配置属性<br>&gt; 2. 获取监听器，发布应用开始启动事件<br>&gt; 3. 初始化输入参数<br>&gt; 4. 配置环境，输出banner<br>&gt; 5. 创建上下文<br>&gt; 6. 预处理上下文<br>&gt; 7. 刷新上下文<br>&gt; 8. 再刷新上下文<br>&gt; 9. 发布应用已经启动事件<br>&gt; 10. 发布应用启动完成事件</p><p>其实上面这段代码，如果只要分析tomcat内容的话，只需要关注两个内容即可，上下文是如何创建的，上下文是如何刷新的，分别对应的方法就是<code>createApplicationContext()</code> 和<code>refreshContext(context)</code>，接下来我们来看看这两个方法做了什么。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">protected ConfigurableApplicationContext createApplicationContext() &#123;</span><br><span class="line">Class&lt;!--?--&gt; contextClass &#x3D; this.applicationContextClass;</span><br><span class="line">if (contextClass &#x3D;&#x3D; null) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">switch (this.webApplicationType) &#123;</span><br><span class="line">case SERVLET:</span><br><span class="line">contextClass &#x3D; Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class="line">break;</span><br><span class="line">case REACTIVE:</span><br><span class="line">contextClass &#x3D; Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">contextClass &#x3D; Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (ClassNotFoundException ex) &#123;</span><br><span class="line">throw new IllegalStateException(</span><br><span class="line">&quot;Unable create a default ApplicationContext, &quot; + &quot;please specify an ApplicationContextClass&quot;,</span><br><span class="line">ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是根据我们的<code>webApplicationType</code> 来判断创建哪种类型的Servlet,代码中分别对应着Web类型(SERVLET),响应式Web类型（REACTIVE),非Web类型（default),我们建立的是Web类型，所以肯定实例化<br><code>DEFAULT_SERVLET_WEB_CONTEXT_CLASS</code>指定的类，也就是<code>AnnotationConfigServletWebServerApplicationContext</code>类，我们来用图来说明下这个类的关系</p><p><img src="https://oscimg.oschina.net/oscnet/ddfa51d6e2de3d57c7422625e51f6250314.jpg" alt=""></p><p>通过这个类图我们可以知道，这个类继承的是<code>ServletWebServerApplicationContext</code>,这就是我们真正的主角，而这个类最终是继承了<code>AbstractApplicationContext</code>，了解完创建上下文的情况后，我们再来看看刷新上下文，相关代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;类：SpringApplication.java</span><br><span class="line"></span><br><span class="line">private void refreshContext(ConfigurableApplicationContext context) &#123;</span><br><span class="line">    &#x2F;&#x2F;直接调用刷新方法</span><br><span class="line">refresh(context);</span><br><span class="line">if (this.registerShutdownHook) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">context.registerShutdownHook();</span><br><span class="line">&#125;</span><br><span class="line">catch (AccessControlException ex) &#123;</span><br><span class="line">&#x2F;&#x2F; Not allowed in some environments.</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;类：SpringApplication.java</span><br><span class="line"></span><br><span class="line">protected void refresh(ApplicationContext applicationContext) &#123;</span><br><span class="line">Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext);</span><br><span class="line">((AbstractApplicationContext) applicationContext).refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还是直接传递调用本类的<code>refresh(context)</code>方法，最后是强转成父类<code>AbstractApplicationContext</code>调用其<code>refresh()</code>方法,该代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 类：AbstractApplicationContext</span><br><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">&#x2F;&#x2F; Prepare this context for refreshing.</span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Tell the subclass to refresh the internal bean factory.</span><br><span class="line">ConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Prepare the bean factory for use in this context.</span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">&#x2F;&#x2F; Allows post-processing of the bean factory in context subclasses.</span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Invoke factory processors registered as beans in the context.</span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Register bean processors that intercept bean creation.</span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Initialize message source for this context.</span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Initialize event multicaster for this context.</span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Initialize other special beans in specific context subclasses.这里的意思就是调用各个子类的onRefresh()</span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Check for listener beans and register them.</span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Instantiate all remaining (non-lazy-init) singletons.</span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Last step: publish corresponding event.</span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">catch (BeansException ex) &#123;</span><br><span class="line">if (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">&quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Destroy already created singletons to avoid dangling resources.</span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Reset &#39;active&#39; flag.</span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Propagate exception to caller.</span><br><span class="line">throw ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">finally &#123;</span><br><span class="line">&#x2F;&#x2F; Reset common introspection caches in Spring&#39;s core, since we</span><br><span class="line">&#x2F;&#x2F; might not ever need metadata for singleton beans anymore...</span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们看到<code>onRefresh()</code>方法是调用其子类的实现，根据我们上文的分析，我们这里的子类是<code>ServletWebServerApplicationContext</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;类：ServletWebServerApplicationContext</span><br><span class="line">protected void onRefresh() &#123;</span><br><span class="line">super.onRefresh();</span><br><span class="line">try &#123;</span><br><span class="line">createWebServer();</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">throw new ApplicationContextException(&quot;Unable to start web server&quot;, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void createWebServer() &#123;</span><br><span class="line">WebServer webServer &#x3D; this.webServer;</span><br><span class="line">ServletContext servletContext &#x3D; getServletContext();</span><br><span class="line">if (webServer &#x3D;&#x3D; null &amp;&amp; servletContext &#x3D;&#x3D; null) &#123;</span><br><span class="line">ServletWebServerFactory factory &#x3D; getWebServerFactory();</span><br><span class="line">this.webServer &#x3D; factory.getWebServer(getSelfInitializer());</span><br><span class="line">&#125;</span><br><span class="line">else if (servletContext !&#x3D; null) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">getSelfInitializer().onStartup(servletContext);</span><br><span class="line">&#125;</span><br><span class="line">catch (ServletException ex) &#123;</span><br><span class="line">throw new ApplicationContextException(&quot;Cannot initialize servlet context&quot;, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">initPropertySources();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，其实庐山真面目已经出来了，<code>createWebServer()</code>就是启动web服务，但是还没有真正启动Tomcat，既然<code>webServer</code>是通过<code>ServletWebServerFactory</code>来获取的，我们就来看看这个工厂的真面目。</p><p><img src="https://oscimg.oschina.net/oscnet/32105bd09038062130bae500d6717f223f8.jpg" alt=""></p><h2 id="走进Tomcat内部"><a href="#走进Tomcat内部" class="headerlink" title="走进Tomcat内部"></a>走进Tomcat内部</h2><p>根据上图我们发现，工厂类是一个接口，各个具体服务的实现是由各个子类来实现的，所以我们就去看看<code>TomcatServletWebServerFactory.getWebServer()</code>的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public WebServer getWebServer(ServletContextInitializer... initializers) &#123;</span><br><span class="line">Tomcat tomcat &#x3D; new Tomcat();</span><br><span class="line">File baseDir &#x3D; (this.baseDirectory !&#x3D; null) ? this.baseDirectory : createTempDir(&quot;tomcat&quot;);</span><br><span class="line">tomcat.setBaseDir(baseDir.getAbsolutePath());</span><br><span class="line">Connector connector &#x3D; new Connector(this.protocol);</span><br><span class="line">tomcat.getService().addConnector(connector);</span><br><span class="line">customizeConnector(connector);</span><br><span class="line">tomcat.setConnector(connector);</span><br><span class="line">tomcat.getHost().setAutoDeploy(false);</span><br><span class="line">configureEngine(tomcat.getEngine());</span><br><span class="line">for (Connector additionalConnector : this.additionalTomcatConnectors) &#123;</span><br><span class="line">tomcat.getService().addConnector(additionalConnector);</span><br><span class="line">&#125;</span><br><span class="line">prepareContext(tomcat.getHost(), initializers);</span><br><span class="line">return getTomcatWebServer(tomcat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面的代码，我们发现其主要做了两件事情，第一件事就是把Connnctor(我们称之为连接器)对象添加到Tomcat中，第二件事就是<code>configureEngine</code>,这连接器我们勉强能理解（不理解后面会述说），那这个<code>Engine</code>是什么呢？我们查看<code>tomcat.getEngine()</code>的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Engine getEngine() &#123;</span><br><span class="line">    Service service &#x3D; getServer().findServices()[0];</span><br><span class="line">    if (service.getContainer() !&#x3D; null) &#123;</span><br><span class="line">        return service.getContainer();</span><br><span class="line">    &#125;</span><br><span class="line">    Engine engine &#x3D; new StandardEngine();</span><br><span class="line">    engine.setName( &quot;Tomcat&quot; );</span><br><span class="line">    engine.setDefaultHost(hostname);</span><br><span class="line">    engine.setRealm(createDefaultRealm());</span><br><span class="line">    service.setContainer(engine);</span><br><span class="line">    return engine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面的源码，我们发现，原来这个Engine是容器，我们继续跟踪源码，找到<code>Container</code>接口</p><p><img src="https://oscimg.oschina.net/oscnet/d46479019a9158e06e887998d303487e90e.jpg" alt=""></p><p>上图中，我们看到了4个子接口，分别是Engine,Host,Context,Wrapper。我们从继承关系上可以知道他们都是容器，那么他们到底有啥区别呢？我看看他们的注释是怎么说的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line"> If used, an Engine is always the top level Container in a Catalina</span><br><span class="line"> * hierarchy. Therefore, the implementation&#39;s &lt;code&gt;setParent()&lt;&#x2F;code&gt; method</span><br><span class="line"> * should throw &lt;code&gt;IllegalArgumentException&lt;&#x2F;code&gt;.</span><br><span class="line"> *</span><br><span class="line"> * @author Craig R. McClanahan</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface Engine extends Container &#123;</span><br><span class="line">    &#x2F;&#x2F;省略代码</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * The parent Container attached to a Host is generally an Engine, but may</span><br><span class="line"> * be some other implementation, or may be omitted if it is not necessary.</span><br><span class="line"> * &lt;&#x2F;p&gt;&lt;p&gt;</span><br><span class="line"> * The child containers attached to a Host are generally implementations</span><br><span class="line"> * of Context (representing an individual servlet context).</span><br><span class="line"> *</span><br><span class="line"> * @author Craig R. McClanahan</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface Host extends Container &#123;</span><br><span class="line">&#x2F;&#x2F;省略代码</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*** &lt;&#x2F;p&gt;&lt;p&gt;</span><br><span class="line"> * The parent Container attached to a Context is generally a Host, but may</span><br><span class="line"> * be some other implementation, or may be omitted if it is not necessary.</span><br><span class="line"> * &lt;&#x2F;p&gt;&lt;p&gt;</span><br><span class="line"> * The child containers attached to a Context are generally implementations</span><br><span class="line"> * of Wrapper (representing individual servlet definitions).</span><br><span class="line"> * &lt;&#x2F;p&gt;&lt;p&gt;</span><br><span class="line"> *</span><br><span class="line"> * @author Craig R. McClanahan</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface Context extends Container, ContextBind &#123;</span><br><span class="line">    &#x2F;&#x2F;省略代码</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**&lt;&#x2F;p&gt;&lt;p&gt;</span><br><span class="line"> * The parent Container attached to a Wrapper will generally be an</span><br><span class="line"> * implementation of Context, representing the servlet context (and</span><br><span class="line"> * therefore the web application) within which this servlet executes.</span><br><span class="line"> * &lt;&#x2F;p&gt;&lt;p&gt;</span><br><span class="line"> * Child Containers are not allowed on Wrapper implementations, so the</span><br><span class="line"> * &lt;code&gt;addChild()&lt;&#x2F;code&gt; method should throw an</span><br><span class="line"> * &lt;code&gt;IllegalArgumentException&lt;&#x2F;code&gt;.</span><br><span class="line"> *</span><br><span class="line"> * @author Craig R. McClanahan</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface Wrapper extends Container &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;省略代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的注释翻译过来就是，<code>Engine</code>是最高级别的容器，其子容器是<code>Host</code>,<code>Host</code>的子容器是<code>Context</code>,<code>Wrapper</code>是<code>Context</code>的子容器，所以这4个容器的关系就是父子关系，也就是<code>Engine</code>&gt;<code>Host</code>&gt;<code>Context</code>&gt;<code>Wrapper</code>。<br>我们再看看<code>Tomcat</code>类的源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;部分源码，其余部分省略。</span><br><span class="line">public class Tomcat &#123;</span><br><span class="line">&#x2F;&#x2F;设置连接器</span><br><span class="line">     public void setConnector(Connector connector) &#123;</span><br><span class="line">        Service service &#x3D; getService();</span><br><span class="line">        boolean found &#x3D; false;</span><br><span class="line">        for (Connector serviceConnector : service.findConnectors()) &#123;</span><br><span class="line">            if (connector &#x3D;&#x3D; serviceConnector) &#123;</span><br><span class="line">                found &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!found) &#123;</span><br><span class="line">            service.addConnector(connector);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;获取service</span><br><span class="line">       public Service getService() &#123;</span><br><span class="line">        return getServer().findServices()[0];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;设置Host容器</span><br><span class="line">     public void setHost(Host host) &#123;</span><br><span class="line">        Engine engine &#x3D; getEngine();</span><br><span class="line">        boolean found &#x3D; false;</span><br><span class="line">        for (Container engineHost : engine.findChildren()) &#123;</span><br><span class="line">            if (engineHost &#x3D;&#x3D; host) &#123;</span><br><span class="line">                found &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!found) &#123;</span><br><span class="line">            engine.addChild(host);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;获取Engine容器</span><br><span class="line">     public Engine getEngine() &#123;</span><br><span class="line">        Service service &#x3D; getServer().findServices()[0];</span><br><span class="line">        if (service.getContainer() !&#x3D; null) &#123;</span><br><span class="line">            return service.getContainer();</span><br><span class="line">        &#125;</span><br><span class="line">        Engine engine &#x3D; new StandardEngine();</span><br><span class="line">        engine.setName( &quot;Tomcat&quot; );</span><br><span class="line">        engine.setDefaultHost(hostname);</span><br><span class="line">        engine.setRealm(createDefaultRealm());</span><br><span class="line">        service.setContainer(engine);</span><br><span class="line">        return engine;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;获取server</span><br><span class="line">       public Server getServer() &#123;</span><br><span class="line"></span><br><span class="line">        if (server !&#x3D; null) &#123;</span><br><span class="line">            return server;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.setProperty(&quot;catalina.useNaming&quot;, &quot;false&quot;);</span><br><span class="line"></span><br><span class="line">        server &#x3D; new StandardServer();</span><br><span class="line"></span><br><span class="line">        initBaseDir();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Set configuration source</span><br><span class="line">        ConfigFileLoader.setSource(new CatalinaBaseConfigurationSource(new File(basedir), null));</span><br><span class="line"></span><br><span class="line">        server.setPort( -1 );</span><br><span class="line"></span><br><span class="line">        Service service &#x3D; new StandardService();</span><br><span class="line">        service.setName(&quot;Tomcat&quot;);</span><br><span class="line">        server.addService(service);</span><br><span class="line">        return server;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;添加Context容器</span><br><span class="line">      public Context addContext(Host host, String contextPath, String contextName,</span><br><span class="line">            String dir) &#123;</span><br><span class="line">        silence(host, contextName);</span><br><span class="line">        Context ctx &#x3D; createContext(host, contextPath);</span><br><span class="line">        ctx.setName(contextName);</span><br><span class="line">        ctx.setPath(contextPath);</span><br><span class="line">        ctx.setDocBase(dir);</span><br><span class="line">        ctx.addLifecycleListener(new FixContextListener());</span><br><span class="line"></span><br><span class="line">        if (host &#x3D;&#x3D; null) &#123;</span><br><span class="line">            getHost().addChild(ctx);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            host.addChild(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#x2F;&#x2F;添加Wrapper容器</span><br><span class="line">         public static Wrapper addServlet(Context ctx,</span><br><span class="line">                                      String servletName,</span><br><span class="line">                                      Servlet servlet) &#123;</span><br><span class="line">        &#x2F;&#x2F; will do class for name and set init params</span><br><span class="line">        Wrapper sw &#x3D; new ExistingStandardWrapper(servlet);</span><br><span class="line">        sw.setName(servletName);</span><br><span class="line">        ctx.addChild(sw);</span><br><span class="line"></span><br><span class="line">        return sw;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阅读<code>Tomcat</code>的<code>getServer()</code>我们可以知道，<code>Tomcat</code>的最顶层是<code>Server</code>,Server就是<code>Tomcat</code>的实例，一个<code>Tomcat</code>一个<code>Server</code>;通过<code>getEngine()</code>我们可以了解到Server下面是Service，而且是多个，一个Service代表我们部署的一个应用，而且我们还可以知道，<code>Engine</code>容器，一个<code>service</code>只有一个；根据父子关系，我们看<code>setHost()</code>源码可以知道，<code>host</code>容器有多个；同理，我们发现<code>addContext()</code>源码下，<code>Context</code>也是多个；<code>addServlet()</code>表明<code>Wrapper</code>容器也是多个，而且这段代码也暗示了，其实<code>Wrapper</code>和<code>Servlet</code>是一层意思。另外我们根据<code>setConnector</code>源码可以知道，连接器(<code>Connector</code>)是设置在<code>service</code>下的，而且是可以设置多个连接器(<code>Connector</code>)。</p><p>根据上面分析，我们可以小结下：<br>Tomcat主要包含了2个核心组件，连接器(Connector)和容器(Container),用图表示如下：</p><p><img src="https://oscimg.oschina.net/oscnet/f5163f6d4c2cf52cc41c757356896693782.jpg" alt=""></p><p>一个<code>Tomcat</code>是一个<code>Server</code>,一个<code>Server</code>下有多个<code>service</code>，也就是我们部署的多个应用，一个应用下有多个连接器(<code>Connector</code>)和一个容器（<code>Container</code>）,容器下有多个子容器，关系用图表示如下：</p><p><img src="https://oscimg.oschina.net/oscnet/a98162cf99f8098dd76d307551593266ce0.jpg" alt=""></p><p><code>Engine</code>下有多个<code>Host</code>子容器，<code>Host</code>下有多个<code>Context</code>子容器，<code>Context</code>下有多个<code>Wrapper</code>子容器。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  SpringBoot的启动是通过<code>new SpringApplication()</code>实例来启动的，启动过程主要做如下几件事情：<br>  &gt;  1. 配置属性<br>&gt; 2. 获取监听器，发布应用开始启动事件<br>&gt; 3. 初始化输入参数<br>&gt; 4. 配置环境，输出banner<br>&gt; 5. 创建上下文<br>&gt; 6. 预处理上下文<br>&gt; 7. 刷新上下文<br>&gt; 8. 再刷新上下文<br>&gt; 9. 发布应用已经启动事件<br>&gt; 10. 发布应用启动完成事件</p><p>而启动Tomcat就是在第7步中“刷新上下文”；Tomcat的启动主要是初始化2个核心组件，连接器(Connector)和容器（Container），一个Tomcat实例就是一个Server，一个Server包含多个Service，也就是多个应用程序，每个Service包含多个连接器（Connetor）和一个容器（Container),而容器下又有多个子容器，按照父子关系分别为：Engine,Host,Context,Wrapper，其中除了Engine外，其余的容器都是可以有多个。</p><h2 id="下期展望"><a href="#下期展望" class="headerlink" title="下期展望"></a>下期展望</h2><p>   本期文章通过SpringBoot的启动来窥探了Tomcat的内部结构，下一期，我们来分析下本次文章中的连接器(<code>Connetor</code>)和容器(Container)的作用，敬请期待。</p><blockquote><p>版权声明：原创文章，转载请注明出处。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Tomcat SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
